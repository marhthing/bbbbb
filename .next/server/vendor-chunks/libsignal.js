/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/libsignal";
exports.ids = ["vendor-chunks/libsignal"];
exports.modules = {

/***/ "(rsc)/./node_modules/libsignal/index.js":
/*!*****************************************!*\
  !*** ./node_modules/libsignal/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.crypto = __webpack_require__(/*! ./src/crypto */ \"(rsc)/./node_modules/libsignal/src/crypto.js\");\nexports.curve = __webpack_require__(/*! ./src/curve */ \"(rsc)/./node_modules/libsignal/src/curve.js\");\nexports.keyhelper = __webpack_require__(/*! ./src/keyhelper */ \"(rsc)/./node_modules/libsignal/src/keyhelper.js\");\nexports.ProtocolAddress = __webpack_require__(/*! ./src/protocol_address */ \"(rsc)/./node_modules/libsignal/src/protocol_address.js\");\nexports.SessionBuilder = __webpack_require__(/*! ./src/session_builder */ \"(rsc)/./node_modules/libsignal/src/session_builder.js\");\nexports.SessionCipher = __webpack_require__(/*! ./src/session_cipher */ \"(rsc)/./node_modules/libsignal/src/session_cipher.js\");\nexports.SessionRecord = __webpack_require__(/*! ./src/session_record */ \"(rsc)/./node_modules/libsignal/src/session_record.js\");\nObject.assign(exports, __webpack_require__(/*! ./src/errors */ \"(rsc)/./node_modules/libsignal/src/errors.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHdHQUF3QztBQUN4QyxxR0FBc0M7QUFDdEMsaUhBQThDO0FBQzlDLHFJQUEyRDtBQUMzRCxrSUFBeUQ7QUFDekQsK0hBQXVEO0FBQ3ZELCtIQUF1RDtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyxrRUFBYyIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbGlic2lnbmFsL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5jcnlwdG8gPSByZXF1aXJlKCcuL3NyYy9jcnlwdG8nKTtcbmV4cG9ydHMuY3VydmUgPSByZXF1aXJlKCcuL3NyYy9jdXJ2ZScpO1xuZXhwb3J0cy5rZXloZWxwZXIgPSByZXF1aXJlKCcuL3NyYy9rZXloZWxwZXInKTtcbmV4cG9ydHMuUHJvdG9jb2xBZGRyZXNzID0gcmVxdWlyZSgnLi9zcmMvcHJvdG9jb2xfYWRkcmVzcycpO1xuZXhwb3J0cy5TZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoJy4vc3JjL3Nlc3Npb25fYnVpbGRlcicpO1xuZXhwb3J0cy5TZXNzaW9uQ2lwaGVyID0gcmVxdWlyZSgnLi9zcmMvc2Vzc2lvbl9jaXBoZXInKTtcbmV4cG9ydHMuU2Vzc2lvblJlY29yZCA9IHJlcXVpcmUoJy4vc3JjL3Nlc3Npb25fcmVjb3JkJyk7XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIHJlcXVpcmUoJy4vc3JjL2Vycm9ycycpKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/minimal.js":
/*!*******************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/minimal.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// minimal library entry point.\r\n\r\n\r\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/index-minimal.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNhO0FBQ2IsOElBQStDIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtaW5pbWFsIGxpYnJhcnkgZW50cnkgcG9pbnQuXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXgtbWluaW1hbFwiKTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/minimal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/index-minimal.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/index-minimal.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nvar protobuf = exports;\r\n\r\n/**\r\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\r\n * @name build\r\n * @type {string}\r\n * @const\r\n */\r\nprotobuf.build = \"minimal\";\r\n\r\n// Serialization\r\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/writer.js\");\r\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/writer_buffer.js\");\r\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/reader.js\");\r\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/reader_buffer.js\");\r\n\r\n// Utility\r\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js\");\r\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/rpc.js\");\r\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/roots.js\");\r\nprotobuf.configure    = configure;\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Reconfigures the library according to the environment.\r\n * @returns {undefined}\r\n */\r\nfunction configure() {\r\n    protobuf.Reader._configure(protobuf.BufferReader);\r\n    protobuf.util._configure();\r\n}\r\n\r\n// Set up buffer utility according to the environment\r\nprotobuf.Writer._configure(protobuf.BufferWriter);\r\nconfigure();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsc0ZBQVU7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsb0dBQWlCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLHNGQUFVO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLG9HQUFpQjtBQUNqRDtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsa0dBQWdCO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLGdGQUFPO0FBQ3ZDLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXHJcbiAqIEBuYW1lIGJ1aWxkXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxucHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcclxuXHJcbi8vIFNlcmlhbGl6YXRpb25cclxucHJvdG9idWYuV3JpdGVyICAgICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xyXG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xyXG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XHJcbnByb3RvYnVmLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlcl9idWZmZXJcIik7XHJcblxyXG4vLyBVdGlsaXR5XHJcbnByb3RvYnVmLnV0aWwgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xyXG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcclxucHJvdG9idWYuY29uZmlndXJlICAgID0gY29uZmlndXJlO1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuLyoqXHJcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuZnVuY3Rpb24gY29uZmlndXJlKCkge1xyXG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcclxuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xyXG59XHJcblxyXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxyXG5wcm90b2J1Zi5Xcml0ZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJXcml0ZXIpO1xyXG5jb25maWd1cmUoKTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/index-minimal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/reader.js":
/*!**********************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/reader.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Reader;\r\n\r\nvar util      = __webpack_require__(/*! ./util/minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar BufferReader; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    utf8      = util.utf8;\r\n\r\n/* istanbul ignore next */\r\nfunction indexOutOfRange(reader, writeLength) {\r\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\r\n}\r\n\r\n/**\r\n * Constructs a new reader instance using the specified buffer.\r\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n * @param {Uint8Array} buffer Buffer to read from\r\n */\r\nfunction Reader(buffer) {\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @type {Uint8Array}\r\n     */\r\n    this.buf = buffer;\r\n\r\n    /**\r\n     * Read buffer position.\r\n     * @type {number}\r\n     */\r\n    this.pos = 0;\r\n\r\n    /**\r\n     * Read buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = buffer.length;\r\n}\r\n\r\nvar create_array = typeof Uint8Array !== \"undefined\"\r\n    ? function create_typed_array(buffer) {\r\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error(\"illegal buffer\");\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array(buffer) {\r\n        if (Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error(\"illegal buffer\");\r\n    };\r\n\r\n/**\r\n * Creates a new reader using the specified buffer.\r\n * @function\r\n * @param {Uint8Array|Buffer} buffer Buffer to read from\r\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\r\n * @throws {Error} If `buffer` is not a valid buffer\r\n */\r\nReader.create = util.Buffer\r\n    ? function create_buffer_setup(buffer) {\r\n        return (Reader.create = function create_buffer(buffer) {\r\n            return util.Buffer.isBuffer(buffer)\r\n                ? new BufferReader(buffer)\r\n                /* istanbul ignore next */\r\n                : create_array(buffer);\r\n        })(buffer);\r\n    }\r\n    /* istanbul ignore next */\r\n    : create_array;\r\n\r\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\r\n\r\n/**\r\n * Reads a varint as an unsigned 32 bit value.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.uint32 = (function read_uint32_setup() {\r\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\r\n    return function read_uint32() {\r\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n\r\n        /* istanbul ignore if */\r\n        if ((this.pos += 5) > this.len) {\r\n            this.pos = this.len;\r\n            throw indexOutOfRange(this, 10);\r\n        }\r\n        return value;\r\n    };\r\n})();\r\n\r\n/**\r\n * Reads a varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.int32 = function read_int32() {\r\n    return this.uint32() | 0;\r\n};\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sint32 = function read_sint32() {\r\n    var value = this.uint32();\r\n    return value >>> 1 ^ -(value & 1) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readLongVarint() {\r\n    // tends to deopt with local vars for octet etc.\r\n    var bits = new LongBits(0, 0);\r\n    var i = 0;\r\n    if (this.len - this.pos > 4) { // fast route (lo)\r\n        for (; i < 4; ++i) {\r\n            // 1st..4th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 5th\r\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\r\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\r\n        if (this.buf[this.pos++] < 128)\r\n            return bits;\r\n        i = 0;\r\n    } else {\r\n        for (; i < 3; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 1st..3th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 4th\r\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\r\n        return bits;\r\n    }\r\n    if (this.len - this.pos > 4) { // fast route (hi)\r\n        for (; i < 5; ++i) {\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    } else {\r\n        for (; i < 5; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    }\r\n    /* istanbul ignore next */\r\n    throw Error(\"invalid varint encoding\");\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads a varint as a signed 64 bit value.\r\n * @name Reader#int64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as an unsigned 64 bit value.\r\n * @name Reader#uint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 64 bit value.\r\n * @name Reader#sint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as a boolean.\r\n * @returns {boolean} Value read\r\n */\r\nReader.prototype.bool = function read_bool() {\r\n    return this.uint32() !== 0;\r\n};\r\n\r\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\r\n    return (buf[end - 4]\r\n          | buf[end - 3] << 8\r\n          | buf[end - 2] << 16\r\n          | buf[end - 1] << 24) >>> 0;\r\n}\r\n\r\n/**\r\n * Reads fixed 32 bits as an unsigned 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.fixed32 = function read_fixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4);\r\n};\r\n\r\n/**\r\n * Reads fixed 32 bits as a signed 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sfixed32 = function read_sfixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readFixed64(/* this: Reader */) {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 8);\r\n\r\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads fixed 64 bits.\r\n * @name Reader#fixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads zig-zag encoded fixed 64 bits.\r\n * @name Reader#sfixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a float (32 bit) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.float = function read_float() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readFloatLE(this.buf, this.pos);\r\n    this.pos += 4;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a double (64 bit float) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.double = function read_double() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readDoubleLE(this.buf, this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @returns {Uint8Array} Value read\r\n */\r\nReader.prototype.bytes = function read_bytes() {\r\n    var length = this.uint32(),\r\n        start  = this.pos,\r\n        end    = this.pos + length;\r\n\r\n    /* istanbul ignore if */\r\n    if (end > this.len)\r\n        throw indexOutOfRange(this, length);\r\n\r\n    this.pos += length;\r\n    if (Array.isArray(this.buf)) // plain array\r\n        return this.buf.slice(start, end);\r\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\r\n        ? new this.buf.constructor(0)\r\n        : this._slice.call(this.buf, start, end);\r\n};\r\n\r\n/**\r\n * Reads a string preceeded by its byte length as a varint.\r\n * @returns {string} Value read\r\n */\r\nReader.prototype.string = function read_string() {\r\n    var bytes = this.bytes();\r\n    return utf8.read(bytes, 0, bytes.length);\r\n};\r\n\r\n/**\r\n * Skips the specified number of bytes if specified, otherwise skips a varint.\r\n * @param {number} [length] Length if known, otherwise a varint is assumed\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skip = function skip(length) {\r\n    if (typeof length === \"number\") {\r\n        /* istanbul ignore if */\r\n        if (this.pos + length > this.len)\r\n            throw indexOutOfRange(this, length);\r\n        this.pos += length;\r\n    } else {\r\n        do {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n        } while (this.buf[this.pos++] & 128);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Skips the next element of the specified wire type.\r\n * @param {number} wireType Wire type received\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skipType = function(wireType) {\r\n    switch (wireType) {\r\n        case 0:\r\n            this.skip();\r\n            break;\r\n        case 1:\r\n            this.skip(8);\r\n            break;\r\n        case 2:\r\n            this.skip(this.uint32());\r\n            break;\r\n        case 3:\r\n            while ((wireType = this.uint32() & 7) !== 4) {\r\n                this.skipType(wireType);\r\n            }\r\n            break;\r\n        case 5:\r\n            this.skip(4);\r\n            break;\r\n\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\r\n    }\r\n    return this;\r\n};\r\n\r\nReader._configure = function(BufferReader_) {\r\n    BufferReader = BufferReader_;\r\n\r\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\r\n    util.merge(Reader.prototype, {\r\n\r\n        int64: function read_int64() {\r\n            return readLongVarint.call(this)[fn](false);\r\n        },\r\n\r\n        uint64: function read_uint64() {\r\n            return readLongVarint.call(this)[fn](true);\r\n        },\r\n\r\n        sint64: function read_sint64() {\r\n            return readLongVarint.call(this).zzDecode()[fn](false);\r\n        },\r\n\r\n        fixed64: function read_fixed64() {\r\n            return readFixed64.call(this)[fn](true);\r\n        },\r\n\r\n        sfixed64: function read_sfixed64() {\r\n            return readFixed64.call(this)[fn](false);\r\n        }\r\n\r\n    });\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0dBQWdCO0FBQ3hDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhLHFCQUFxQixHQUFHLG9CQUFvQixzQ0FBc0M7QUFDL0YsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xyXG5cclxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xyXG5cclxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXHJcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xyXG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXHJcbiAqL1xyXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGJ1ZmZlci5cclxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3MgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xyXG59XHJcblxyXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcclxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcclxuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcclxuICAgIH07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyByZWFkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxyXG4gKiBAcmV0dXJucyB7UmVhZGVyfEJ1ZmZlclJlYWRlcn0gQSB7QGxpbmsgQnVmZmVyUmVhZGVyfSBpZiBgYnVmZmVyYCBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGEge0BsaW5rIFJlYWRlcn1cclxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxyXG4gKi9cclxuUmVhZGVyLmNyZWF0ZSA9IHV0aWwuQnVmZmVyXHJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcclxuICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcclxuICAgICAgICB9KShidWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogY3JlYXRlX2FycmF5O1xyXG5cclxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IChmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcclxuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XHJcbiAgICAgICAgdmFsdWUgPSAoICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3NdICYgMTI3ICAgICAgICkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XHJcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcclxuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xyXG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcclxuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XHJcbn07XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cclxuXHJcbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xyXG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXHJcbiAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcclxuICAgIHZhciBpID0gMDtcclxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcclxuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xyXG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxyXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA1dGhcclxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XHJcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xyXG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXHJcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDR0aFxyXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xyXG4gICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxyXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxyXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxyXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcclxufVxyXG5cclxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXHJcbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxyXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxyXG4gKiBAbmFtZSBSZWFkZXIjc2ludDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIGJvb2xlYW4uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcclxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXHJcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAzXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG4vKipcclxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcclxuXHJcbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XHJcblxyXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xyXG59O1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXHJcblxyXG5mdW5jdGlvbiByZWFkRml4ZWQ2NCgvKiB0aGlzOiBSZWFkZXIgKi8pIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcclxufVxyXG5cclxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBmaXhlZCA2NCBiaXRzLlxyXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXHJcbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcclxuXHJcbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XHJcbiAgICB0aGlzLnBvcyArPSA0O1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpIGFzIGEgbnVtYmVyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XHJcblxyXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcclxuICAgIHRoaXMucG9zICs9IDg7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xyXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXHJcbiAgICAgICAgc3RhcnQgID0gdGhpcy5wb3MsXHJcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XHJcblxyXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcclxuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXHJcbiAgICAgICAgPyBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMClcclxuICAgICAgICA6IHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XHJcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XHJcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxyXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XHJcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxyXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcclxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcclxuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXHJcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xyXG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcclxuXHJcbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xyXG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XHJcblxyXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/reader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/reader_buffer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/reader_buffer.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = BufferReader;\r\n\r\n// extends Reader\r\nvar Reader = __webpack_require__(/*! ./reader */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/reader.js\");\r\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n/**\r\n * Constructs a new buffer reader instance.\r\n * @classdesc Wire format reader using node buffers.\r\n * @extends Reader\r\n * @constructor\r\n * @param {Buffer} buffer Buffer to read from\r\n */\r\nfunction BufferReader(buffer) {\r\n    Reader.call(this, buffer);\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @name BufferReader#buf\r\n     * @type {Buffer}\r\n     */\r\n}\r\n\r\n/* istanbul ignore else */\r\nif (util.Buffer)\r\n    BufferReader.prototype._slice = util.Buffer.prototype.slice;\r\n\r\n/**\r\n * @override\r\n */\r\nBufferReader.prototype.string = function read_string_buffer() {\r\n    var len = this.uint32(); // modifies pos\r\n    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @name BufferReader#bytes\r\n * @function\r\n * @returns {Buffer} Value read\r\n */\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNGQUFVO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsa0dBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xyXG5cclxuLy8gZXh0ZW5kcyBSZWFkZXJcclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcclxuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxyXG4gKiBAZXh0ZW5kcyBSZWFkZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxyXG4gKi9cclxuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xyXG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYnVmZmVyLlxyXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxyXG4gICAgICogQHR5cGUge0J1ZmZlcn1cclxuICAgICAqL1xyXG59XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5pZiAodXRpbC5CdWZmZXIpXHJcbiAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xyXG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxyXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/reader_buffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/roots.js":
/*!*********************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/roots.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = {};\r\n\r\n/**\r\n * Named roots.\r\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\r\n * Can also be used manually to make roots available accross modules.\r\n * @name roots\r\n * @type {Object.<string,Root>}\r\n * @example\r\n * // pbjs -r myroot -o compiled.js ...\r\n *\r\n * // in another module:\r\n * require(\"./compiled.js\");\r\n *\r\n * // in any subsequent module:\r\n * var root = protobuf.roots[\"myroot\"];\r\n */\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBOYW1lZCByb290cy5cclxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXHJcbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNjcm9zcyBtb2R1bGVzLlxyXG4gKiBAbmFtZSByb290c1xyXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUm9vdD59XHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxyXG4gKlxyXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcclxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XHJcbiAqXHJcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcclxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcclxuICovXHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/roots.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/rpc.js":
/*!*******************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/rpc.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\n/**\r\n * Streaming RPC helpers.\r\n * @namespace\r\n */\r\nvar rpc = exports;\r\n\r\n/**\r\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\r\n * @typedef RPCImpl\r\n * @type {function}\r\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\r\n * @param {Uint8Array} requestData Request data\r\n * @param {RPCImplCallback} callback Callback function\r\n * @returns {undefined}\r\n * @example\r\n * function rpcImpl(method, requestData, callback) {\r\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\r\n *         throw Error(\"no such method\");\r\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\r\n *         callback(err, responseData);\r\n *     });\r\n * }\r\n */\r\n\r\n/**\r\n * Node-style callback as used by {@link RPCImpl}.\r\n * @typedef RPCImplCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any, otherwise `null`\r\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/rpc/service.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFzQjtBQUN2RDtBQUNBLFVBQVU7QUFDVixXQUFXLG1DQUFtQyxZQUFZLElBQUk7QUFDOUQsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBLFVBQVU7QUFDVixXQUFXLFlBQVk7QUFDdkIsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0dBQWUiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2xpYnNpZ25hbC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHJwYyA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxyXG4gKiBAdHlwZWRlZiBSUENJbXBsXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXHJcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XHJcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcclxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xyXG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XHJcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xyXG4gKiAgICAgfSk7XHJcbiAqIH1cclxuICovXHJcblxyXG4vKipcclxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cclxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/rpc.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/rpc/service.js":
/*!***************************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/rpc/service.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Service;\r\n\r\nvar util = __webpack_require__(/*! ../util/minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n// Extends EventEmitter\r\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\r\n\r\n/**\r\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\r\n *\r\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\r\n * @typedef rpc.ServiceMethodCallback\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {TRes} [response] Response message\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\r\n * @typedef rpc.ServiceMethod\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\r\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\r\n */\r\n\r\n/**\r\n * Constructs a new RPC service instance.\r\n * @classdesc An RPC service as returned by {@link Service#create}.\r\n * @exports rpc.Service\r\n * @extends util.EventEmitter\r\n * @constructor\r\n * @param {RPCImpl} rpcImpl RPC implementation\r\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\r\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\r\n */\r\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\r\n\r\n    if (typeof rpcImpl !== \"function\")\r\n        throw TypeError(\"rpcImpl must be a function\");\r\n\r\n    util.EventEmitter.call(this);\r\n\r\n    /**\r\n     * RPC implementation. Becomes `null` once the service is ended.\r\n     * @type {RPCImpl|null}\r\n     */\r\n    this.rpcImpl = rpcImpl;\r\n\r\n    /**\r\n     * Whether requests are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.requestDelimited = Boolean(requestDelimited);\r\n\r\n    /**\r\n     * Whether responses are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.responseDelimited = Boolean(responseDelimited);\r\n}\r\n\r\n/**\r\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\r\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\r\n * @param {Constructor<TReq>} requestCtor Request constructor\r\n * @param {Constructor<TRes>} responseCtor Response constructor\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\r\n * @returns {undefined}\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n */\r\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\r\n\r\n    if (!request)\r\n        throw TypeError(\"request must be specified\");\r\n\r\n    var self = this;\r\n    if (!callback)\r\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\r\n\r\n    if (!self.rpcImpl) {\r\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        return self.rpcImpl(\r\n            method,\r\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\r\n            function rpcCallback(err, response) {\r\n\r\n                if (err) {\r\n                    self.emit(\"error\", err, method);\r\n                    return callback(err);\r\n                }\r\n\r\n                if (response === null) {\r\n                    self.end(/* endedByRPC */ true);\r\n                    return undefined;\r\n                }\r\n\r\n                if (!(response instanceof responseCtor)) {\r\n                    try {\r\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\r\n                    } catch (err) {\r\n                        self.emit(\"error\", err, method);\r\n                        return callback(err);\r\n                    }\r\n                }\r\n\r\n                self.emit(\"data\", response, method);\r\n                return callback(null, response);\r\n            }\r\n        );\r\n    } catch (err) {\r\n        self.emit(\"error\", err, method);\r\n        setTimeout(function() { callback(err); }, 0);\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Ends this service and emits the `end` event.\r\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\r\n * @returns {rpc.Service} `this`\r\n */\r\nService.prototype.end = function end(endedByRPC) {\r\n    if (this.rpcImpl) {\r\n        if (!endedByRPC) // signal end to rpcImpl\r\n            this.rpcImpl(null, null, null);\r\n        this.rpcImpl = null;\r\n        this.emit(\"end\").off();\r\n    }\r\n    return this;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsbUdBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0NBQXNDO0FBQy9FO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsWUFBWTtBQUN2QixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUIsZUFBZSxxQkFBcUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckUsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2xpYnNpZ25hbC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXHJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xyXG5cclxuLyoqXHJcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXHJcbiAqXHJcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxyXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXHJcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cclxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcclxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XHJcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcclxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXHJcbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXHJcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcclxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcblxyXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cclxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXHJcbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxyXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XHJcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cclxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgaWYgKCFyZXF1ZXN0KVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKCFjYWxsYmFjaylcclxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcclxuXHJcbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xyXG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xyXG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXHJcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/rpc/service.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/longbits.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/util/longbits.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = LongBits;\r\n\r\nvar util = __webpack_require__(/*! ../util/minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n/**\r\n * Constructs new long bits.\r\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\r\n * @memberof util\r\n * @constructor\r\n * @param {number} lo Low 32 bits, unsigned\r\n * @param {number} hi High 32 bits, unsigned\r\n */\r\nfunction LongBits(lo, hi) {\r\n\r\n    // note that the casts below are theoretically unnecessary as of today, but older statically\r\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\r\n\r\n    /**\r\n     * Low bits.\r\n     * @type {number}\r\n     */\r\n    this.lo = lo >>> 0;\r\n\r\n    /**\r\n     * High bits.\r\n     * @type {number}\r\n     */\r\n    this.hi = hi >>> 0;\r\n}\r\n\r\n/**\r\n * Zero bits.\r\n * @memberof util.LongBits\r\n * @type {util.LongBits}\r\n */\r\nvar zero = LongBits.zero = new LongBits(0, 0);\r\n\r\nzero.toNumber = function() { return 0; };\r\nzero.zzEncode = zero.zzDecode = function() { return this; };\r\nzero.length = function() { return 1; };\r\n\r\n/**\r\n * Zero hash.\r\n * @memberof util.LongBits\r\n * @type {string}\r\n */\r\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\r\n\r\n/**\r\n * Constructs new long bits from the specified number.\r\n * @param {number} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.fromNumber = function fromNumber(value) {\r\n    if (value === 0)\r\n        return zero;\r\n    var sign = value < 0;\r\n    if (sign)\r\n        value = -value;\r\n    var lo = value >>> 0,\r\n        hi = (value - lo) / 4294967296 >>> 0;\r\n    if (sign) {\r\n        hi = ~hi >>> 0;\r\n        lo = ~lo >>> 0;\r\n        if (++lo > 4294967295) {\r\n            lo = 0;\r\n            if (++hi > 4294967295)\r\n                hi = 0;\r\n        }\r\n    }\r\n    return new LongBits(lo, hi);\r\n};\r\n\r\n/**\r\n * Constructs new long bits from a number, long or string.\r\n * @param {Long|number|string} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.from = function from(value) {\r\n    if (typeof value === \"number\")\r\n        return LongBits.fromNumber(value);\r\n    if (util.isString(value)) {\r\n        /* istanbul ignore else */\r\n        if (util.Long)\r\n            value = util.Long.fromString(value);\r\n        else\r\n            return LongBits.fromNumber(parseInt(value, 10));\r\n    }\r\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a possibly unsafe JavaScript number.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {number} Possibly unsafe number\r\n */\r\nLongBits.prototype.toNumber = function toNumber(unsigned) {\r\n    if (!unsigned && this.hi >>> 31) {\r\n        var lo = ~this.lo + 1 >>> 0,\r\n            hi = ~this.hi     >>> 0;\r\n        if (!lo)\r\n            hi = hi + 1 >>> 0;\r\n        return -(lo + hi * 4294967296);\r\n    }\r\n    return this.lo + this.hi * 4294967296;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a long.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long} Long\r\n */\r\nLongBits.prototype.toLong = function toLong(unsigned) {\r\n    return util.Long\r\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\r\n        /* istanbul ignore next */\r\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\r\n};\r\n\r\nvar charCodeAt = String.prototype.charCodeAt;\r\n\r\n/**\r\n * Constructs new long bits from the specified 8 characters long hash.\r\n * @param {string} hash Hash\r\n * @returns {util.LongBits} Bits\r\n */\r\nLongBits.fromHash = function fromHash(hash) {\r\n    if (hash === zeroHash)\r\n        return zero;\r\n    return new LongBits(\r\n        ( charCodeAt.call(hash, 0)\r\n        | charCodeAt.call(hash, 1) << 8\r\n        | charCodeAt.call(hash, 2) << 16\r\n        | charCodeAt.call(hash, 3) << 24) >>> 0\r\n    ,\r\n        ( charCodeAt.call(hash, 4)\r\n        | charCodeAt.call(hash, 5) << 8\r\n        | charCodeAt.call(hash, 6) << 16\r\n        | charCodeAt.call(hash, 7) << 24) >>> 0\r\n    );\r\n};\r\n\r\n/**\r\n * Converts this long bits to a 8 characters long hash.\r\n * @returns {string} Hash\r\n */\r\nLongBits.prototype.toHash = function toHash() {\r\n    return String.fromCharCode(\r\n        this.lo        & 255,\r\n        this.lo >>> 8  & 255,\r\n        this.lo >>> 16 & 255,\r\n        this.lo >>> 24      ,\r\n        this.hi        & 255,\r\n        this.hi >>> 8  & 255,\r\n        this.hi >>> 16 & 255,\r\n        this.hi >>> 24\r\n    );\r\n};\r\n\r\n/**\r\n * Zig-zag encodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzEncode = function zzEncode() {\r\n    var mask =   this.hi >> 31;\r\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\r\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Zig-zag decodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzDecode = function zzDecode() {\r\n    var mask = -(this.lo & 1);\r\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\r\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Calculates the length of this longbits when encoded as a varint.\r\n * @returns {number} Length\r\n */\r\nLongBits.prototype.length = function length() {\r\n    var part0 =  this.lo,\r\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\r\n        part2 =  this.hi >>> 24;\r\n    return part2 === 0\r\n         ? part1 === 0\r\n           ? part0 < 16384\r\n             ? part0 < 128 ? 1 : 2\r\n             : part0 < 2097152 ? 3 : 4\r\n           : part1 < 16384\r\n             ? part1 < 128 ? 5 : 6\r\n             : part1 < 2097152 ? 7 : 8\r\n         : part2 < 128 ? 9 : 10;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxtR0FBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZDQUE2QztBQUM3QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cclxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcclxuXHJcbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxyXG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb3cgYml0cy5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZ2ggYml0cy5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFplcm8gYml0cy5cclxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcclxuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XHJcbiAqL1xyXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XHJcblxyXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xyXG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcclxuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XHJcblxyXG4vKipcclxuICogWmVybyBoYXNoLlxyXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcclxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXHJcbiAqL1xyXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSAwKVxyXG4gICAgICAgIHJldHVybiB6ZXJvO1xyXG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XHJcbiAgICBpZiAoc2lnbilcclxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcclxuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxyXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcclxuICAgIGlmIChzaWduKSB7XHJcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XHJcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XHJcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XHJcbiAgICAgICAgICAgIGxvID0gMDtcclxuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxyXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcclxuICovXHJcbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKHV0aWwuTG9uZylcclxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cclxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XHJcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxyXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcclxuICAgICAgICBpZiAoIWxvKVxyXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcclxuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cclxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gdXRpbC5Mb25nXHJcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xyXG59O1xyXG5cclxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXHJcbiAqL1xyXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcclxuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcclxuICAgICAgICByZXR1cm4gemVybztcclxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXHJcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcclxuICAgICxcclxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxyXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxyXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcclxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcclxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiAyNFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xyXG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XHJcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XHJcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xyXG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcclxuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcclxuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cclxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xyXG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXHJcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxyXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xyXG4gICAgcmV0dXJuIHBhcnQyID09PSAwXHJcbiAgICAgICAgID8gcGFydDEgPT09IDBcclxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcclxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxyXG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxyXG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XHJcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XHJcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/longbits.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js":
/*!****************************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar util = exports;\r\n\r\n// used to return a Promise where callback is omitted\r\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"(rsc)/./node_modules/@protobufjs/aspromise/index.js\");\r\n\r\n// converts to / from base64 encoded strings\r\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"(rsc)/./node_modules/@protobufjs/base64/index.js\");\r\n\r\n// base class of rpc.Service\r\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"(rsc)/./node_modules/@protobufjs/eventemitter/index.js\");\r\n\r\n// float handling accross browsers\r\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"(rsc)/./node_modules/@protobufjs/float/index.js\");\r\n\r\n// requires modules optionally and hides the call from bundlers\r\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"(rsc)/./node_modules/@protobufjs/inquire/index.js\");\r\n\r\n// converts to / from utf8 encoded strings\r\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"(rsc)/./node_modules/@protobufjs/utf8/index.js\");\r\n\r\n// provides a node-like buffer pool in the browser\r\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"(rsc)/./node_modules/@protobufjs/pool/index.js\");\r\n\r\n// utility to work with the low and high bits of a 64 bit value\r\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/longbits.js\");\r\n\r\n// global object reference\r\nutil.global = typeof window !== \"undefined\" && window\r\n           || typeof global !== \"undefined\" && global\r\n           || typeof self   !== \"undefined\" && self\r\n           || this; // eslint-disable-line no-invalid-this\r\n\r\n/**\r\n * An immuable empty array.\r\n * @memberof util\r\n * @type {Array.<*>}\r\n * @const\r\n */\r\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\r\n\r\n/**\r\n * An immutable empty object.\r\n * @type {Object}\r\n * @const\r\n */\r\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\r\n\r\n/**\r\n * Whether running within node or not.\r\n * @memberof util\r\n * @type {boolean}\r\n * @const\r\n */\r\nutil.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);\r\n\r\n/**\r\n * Tests if the specified value is an integer.\r\n * @function\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is an integer\r\n */\r\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\r\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a string.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a string\r\n */\r\nutil.isString = function isString(value) {\r\n    return typeof value === \"string\" || value instanceof String;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a non-null object.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a non-null object\r\n */\r\nutil.isObject = function isObject(value) {\r\n    return value && typeof value === \"object\";\r\n};\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * This is an alias of {@link util.isSet}.\r\n * @function\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isset =\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isSet = function isSet(obj, prop) {\r\n    var value = obj[prop];\r\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\r\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Any compatible Buffer instance.\r\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\r\n * @interface Buffer\r\n * @extends Uint8Array\r\n */\r\n\r\n/**\r\n * Node's Buffer class if available.\r\n * @type {Constructor<Buffer>}\r\n */\r\nutil.Buffer = (function() {\r\n    try {\r\n        var Buffer = util.inquire(\"buffer\").Buffer;\r\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\r\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\r\n    } catch (e) {\r\n        /* istanbul ignore next */\r\n        return null;\r\n    }\r\n})();\r\n\r\n// Internal alias of or polyfull for Buffer.from.\r\nutil._Buffer_from = null;\r\n\r\n// Internal alias of or polyfill for Buffer.allocUnsafe.\r\nutil._Buffer_allocUnsafe = null;\r\n\r\n/**\r\n * Creates a new buffer of whatever type supported by the environment.\r\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\r\n * @returns {Uint8Array|Buffer} Buffer\r\n */\r\nutil.newBuffer = function newBuffer(sizeOrArray) {\r\n    /* istanbul ignore next */\r\n    return typeof sizeOrArray === \"number\"\r\n        ? util.Buffer\r\n            ? util._Buffer_allocUnsafe(sizeOrArray)\r\n            : new util.Array(sizeOrArray)\r\n        : util.Buffer\r\n            ? util._Buffer_from(sizeOrArray)\r\n            : typeof Uint8Array === \"undefined\"\r\n                ? sizeOrArray\r\n                : new Uint8Array(sizeOrArray);\r\n};\r\n\r\n/**\r\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\r\n * @type {Constructor<Uint8Array>}\r\n */\r\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\r\n\r\n/**\r\n * Any compatible Long instance.\r\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\r\n * @interface Long\r\n * @property {number} low Low bits\r\n * @property {number} high High bits\r\n * @property {boolean} unsigned Whether unsigned or not\r\n */\r\n\r\n/**\r\n * Long.js's Long class if available.\r\n * @type {Constructor<Long>}\r\n */\r\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\r\n         || /* istanbul ignore next */ util.global.Long\r\n         || util.inquire(\"long\");\r\n\r\n/**\r\n * Regular expression used to verify 2 bit (`bool`) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key2Re = /^true|false|0|1$/;\r\n\r\n/**\r\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\r\n\r\n/**\r\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\r\n\r\n/**\r\n * Converts a number or long to an 8 characters long hash string.\r\n * @param {Long|number} value Value to convert\r\n * @returns {string} Hash\r\n */\r\nutil.longToHash = function longToHash(value) {\r\n    return value\r\n        ? util.LongBits.from(value).toHash()\r\n        : util.LongBits.zeroHash;\r\n};\r\n\r\n/**\r\n * Converts an 8 characters long hash string to a long or number.\r\n * @param {string} hash Hash\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long|number} Original value\r\n */\r\nutil.longFromHash = function longFromHash(hash, unsigned) {\r\n    var bits = util.LongBits.fromHash(hash);\r\n    if (util.Long)\r\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\r\n    return bits.toNumber(Boolean(unsigned));\r\n};\r\n\r\n/**\r\n * Merges the properties of the source object into the destination object.\r\n * @memberof util\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {Object.<string,*>} src Source object\r\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\r\n * @returns {Object.<string,*>} Destination object\r\n */\r\nfunction merge(dst, src, ifNotSet) { // used by converters\r\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\r\n        if (dst[keys[i]] === undefined || !ifNotSet)\r\n            dst[keys[i]] = src[keys[i]];\r\n    return dst;\r\n}\r\n\r\nutil.merge = merge;\r\n\r\n/**\r\n * Converts the first character of a string to lower case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.lcFirst = function lcFirst(str) {\r\n    return str.charAt(0).toLowerCase() + str.substring(1);\r\n};\r\n\r\n/**\r\n * Creates a custom error constructor.\r\n * @memberof util\r\n * @param {string} name Error name\r\n * @returns {Constructor<Error>} Custom error constructor\r\n */\r\nfunction newError(name) {\r\n\r\n    function CustomError(message, properties) {\r\n\r\n        if (!(this instanceof CustomError))\r\n            return new CustomError(message, properties);\r\n\r\n        // Error.call(this, message);\r\n        // ^ just returns a new error instance because the ctor can be called as a function\r\n\r\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\r\n\r\n        /* istanbul ignore next */\r\n        if (Error.captureStackTrace) // node\r\n            Error.captureStackTrace(this, CustomError);\r\n        else\r\n            Object.defineProperty(this, \"stack\", { value: (new Error()).stack || \"\" });\r\n\r\n        if (properties)\r\n            merge(this, properties);\r\n    }\r\n\r\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\r\n\r\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\r\n\r\n    CustomError.prototype.toString = function toString() {\r\n        return this.name + \": \" + this.message;\r\n    };\r\n\r\n    return CustomError;\r\n}\r\n\r\nutil.newError = newError;\r\n\r\n/**\r\n * Constructs a new protocol error.\r\n * @classdesc Error subclass indicating a protocol specifc error.\r\n * @memberof util\r\n * @extends Error\r\n * @template T extends Message<T>\r\n * @constructor\r\n * @param {string} message Error message\r\n * @param {Object.<string,*>} [properties] Additional properties\r\n * @example\r\n * try {\r\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\r\n * } catch (e) {\r\n *     if (e instanceof ProtocolError && e.instance)\r\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\r\n * }\r\n */\r\nutil.ProtocolError = newError(\"ProtocolError\");\r\n\r\n/**\r\n * So far decoded message instance.\r\n * @name util.ProtocolError#instance\r\n * @type {Message<T>}\r\n */\r\n\r\n/**\r\n * A OneOf getter as returned by {@link util.oneOfGetter}.\r\n * @typedef OneOfGetter\r\n * @type {function}\r\n * @returns {string|undefined} Set field name, if any\r\n */\r\n\r\n/**\r\n * Builds a getter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfGetter} Unbound getter\r\n */\r\nutil.oneOfGetter = function getOneOf(fieldNames) {\r\n    var fieldMap = {};\r\n    for (var i = 0; i < fieldNames.length; ++i)\r\n        fieldMap[fieldNames[i]] = 1;\r\n\r\n    /**\r\n     * @returns {string|undefined} Set field name, if any\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function() { // eslint-disable-line consistent-return\r\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\r\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\r\n                return keys[i];\r\n    };\r\n};\r\n\r\n/**\r\n * A OneOf setter as returned by {@link util.oneOfSetter}.\r\n * @typedef OneOfSetter\r\n * @type {function}\r\n * @param {string|undefined} value Field name\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Builds a setter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfSetter} Unbound setter\r\n */\r\nutil.oneOfSetter = function setOneOf(fieldNames) {\r\n\r\n    /**\r\n     * @param {string} name Field name\r\n     * @returns {undefined}\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function(name) {\r\n        for (var i = 0; i < fieldNames.length; ++i)\r\n            if (fieldNames[i] !== name)\r\n                delete this[fieldNames[i]];\r\n    };\r\n};\r\n\r\n/**\r\n * Default conversion options used for {@link Message#toJSON} implementations.\r\n *\r\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\r\n *\r\n * - Longs become strings\r\n * - Enums become string keys\r\n * - Bytes become base64 encoded strings\r\n * - (Sub-)Messages become plain objects\r\n * - Maps become plain objects with all string keys\r\n * - Repeated fields become arrays\r\n * - NaN and Infinity for float and double fields become strings\r\n *\r\n * @type {IConversionOptions}\r\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\r\n */\r\nutil.toJSONOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    bytes: String,\r\n    json: true\r\n};\r\n\r\n// Sets up buffer utility according to the environment (called in index-minimal)\r\nutil._configure = function() {\r\n    var Buffer = util.Buffer;\r\n    /* istanbul ignore if */\r\n    if (!Buffer) {\r\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\r\n        return;\r\n    }\r\n    // because node 4.x buffers are incompatible & immutable\r\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\r\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\r\n        /* istanbul ignore next */\r\n        function Buffer_from(value, encoding) {\r\n            return new Buffer(value, encoding);\r\n        };\r\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\r\n        /* istanbul ignore next */\r\n        function Buffer_allocUnsafe(size) {\r\n            return new Buffer(size);\r\n        };\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBdUI7QUFDaEQ7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw0RUFBb0I7QUFDMUM7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHdGQUEwQjtBQUN0RDtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDBFQUFtQjtBQUN4QztBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFxQjtBQUM1QztBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHdFQUFrQjtBQUN0QztBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHdFQUFrQjtBQUN0QztBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsK0ZBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsbURBQW1ELG1DQUFtQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esa0NBQWtDLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0EscUNBQXFDO0FBQ3JDLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCLG1CQUFtQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtDQUFrQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0IsZ0JBQWdCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxVQUFVO0FBQ1YsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsZ0VBQWdFLFFBQVE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBLFVBQVU7QUFDVixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciB1dGlsID0gZXhwb3J0cztcclxuXHJcbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXHJcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcclxuXHJcbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXHJcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcclxuXHJcbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcclxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xyXG5cclxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xyXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xyXG5cclxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXHJcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xyXG5cclxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXHJcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xyXG5cclxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XHJcblxyXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcclxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xyXG5cclxuLy8gZ2xvYmFsIG9iamVjdCByZWZlcmVuY2VcclxudXRpbC5nbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xyXG4gICAgICAgICAgIHx8IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsXHJcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXHJcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcclxuXHJcbi8qKlxyXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHR5cGUge0FycmF5LjwqPn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXHJcblxyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cclxuICogQHR5cGUge09iamVjdH1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAY29uc3RcclxuICovXHJcbnV0aWwuaXNOb2RlID0gQm9vbGVhbih1dGlsLmdsb2JhbC5wcm9jZXNzICYmIHV0aWwuZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMgJiYgdXRpbC5nbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxyXG4gKi9cclxudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xyXG4gKi9cclxudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxyXG4gKi9cclxudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXHJcbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gKi9cclxudXRpbC5pc3NldCA9XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gKi9cclxudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xyXG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxyXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cclxuICogQGludGVyZmFjZSBCdWZmZXJcclxuICogQGV4dGVuZHMgVWludDhBcnJheVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cclxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XHJcbiAqL1xyXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XHJcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxyXG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufSkoKTtcclxuXHJcbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cclxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xyXG5cclxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cclxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXHJcbiAqL1xyXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcclxuICAgICAgICA/IHV0aWwuQnVmZmVyXHJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxyXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxyXG4gICAgICAgIDogdXRpbC5CdWZmZXJcclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcclxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxyXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxyXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXHJcbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cclxuICovXHJcbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcclxuXHJcbi8qKlxyXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxyXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cclxuICogQGludGVyZmFjZSBMb25nXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcclxuICovXHJcblxyXG4vKipcclxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxyXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XHJcbiAqL1xyXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xyXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXHJcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XHJcblxyXG4vKipcclxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxyXG4gKiBAdHlwZSB7UmVnRXhwfVxyXG4gKiBAY29uc3RcclxuICovXHJcbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xyXG5cclxuLyoqXHJcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXHJcbiAqIEB0eXBlIHtSZWdFeHB9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XHJcblxyXG4vKipcclxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cclxuICogQHR5cGUge1JlZ0V4cH1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cclxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXHJcbiAqL1xyXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWVcclxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcclxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcclxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxyXG4gKi9cclxudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcclxuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcclxuICAgIGlmICh1dGlsLkxvbmcpXHJcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XHJcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcclxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcclxuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcclxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG5cclxudXRpbC5tZXJnZSA9IG1lcmdlO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXHJcbiAqL1xyXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxyXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XHJcblxyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XHJcblxyXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiAobmV3IEVycm9yKCkpLnN0YWNrIHx8IFwiXCIgfSk7XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxuXHJcbiAgICAoQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEN1c3RvbUVycm9yO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9IH0pO1xyXG5cclxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcclxufVxyXG5cclxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXHJcbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBleHRlbmRzIEVycm9yXHJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXHJcbiAqIEBleGFtcGxlXHJcbiAqIHRyeSB7XHJcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAqIH0gY2F0Y2ggKGUpIHtcclxuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxyXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xyXG4gKiB9XHJcbiAqL1xyXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XHJcblxyXG4vKipcclxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cclxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXHJcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXHJcbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcclxuICovXHJcblxyXG4vKipcclxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxyXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXHJcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcclxuICovXHJcbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XHJcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcclxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxyXG4gICAgICogQHRoaXMgT2JqZWN0XHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxyXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXHJcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXHJcbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xyXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXHJcbiAqL1xyXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAqIEB0aGlzIE9iamVjdFxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxyXG4gKlxyXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXHJcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXHJcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcclxuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xyXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcclxuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xyXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXHJcbiAqXHJcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXHJcbiAqL1xyXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XHJcbiAgICBsb25nczogU3RyaW5nLFxyXG4gICAgZW51bXM6IFN0cmluZyxcclxuICAgIGJ5dGVzOiBTdHJpbmcsXHJcbiAgICBqc29uOiB0cnVlXHJcbn07XHJcblxyXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxyXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFCdWZmZXIpIHtcclxuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcclxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcclxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XHJcbiAgICAgICAgfTtcclxuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XHJcbiAgICAgICAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/writer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/writer.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Writer;\r\n\r\nvar util      = __webpack_require__(/*! ./util/minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar BufferWriter; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    base64    = util.base64,\r\n    utf8      = util.utf8;\r\n\r\n/**\r\n * Constructs a new writer operation instance.\r\n * @classdesc Scheduled writer operation.\r\n * @constructor\r\n * @param {function(*, Uint8Array, number)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {*} val Value to write\r\n * @ignore\r\n */\r\nfunction Op(fn, len, val) {\r\n\r\n    /**\r\n     * Function to call.\r\n     * @type {function(Uint8Array, number, *)}\r\n     */\r\n    this.fn = fn;\r\n\r\n    /**\r\n     * Value byte length.\r\n     * @type {number}\r\n     */\r\n    this.len = len;\r\n\r\n    /**\r\n     * Next operation.\r\n     * @type {Writer.Op|undefined}\r\n     */\r\n    this.next = undefined;\r\n\r\n    /**\r\n     * Value to write.\r\n     * @type {*}\r\n     */\r\n    this.val = val; // type varies\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction noop() {} // eslint-disable-line no-empty-function\r\n\r\n/**\r\n * Constructs a new writer state instance.\r\n * @classdesc Copied writer state.\r\n * @memberof Writer\r\n * @constructor\r\n * @param {Writer} writer Writer to copy state from\r\n * @ignore\r\n */\r\nfunction State(writer) {\r\n\r\n    /**\r\n     * Current head.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.head = writer.head;\r\n\r\n    /**\r\n     * Current tail.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.tail = writer.tail;\r\n\r\n    /**\r\n     * Current buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = writer.len;\r\n\r\n    /**\r\n     * Next state.\r\n     * @type {State|null}\r\n     */\r\n    this.next = writer.states;\r\n}\r\n\r\n/**\r\n * Constructs a new writer instance.\r\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n */\r\nfunction Writer() {\r\n\r\n    /**\r\n     * Current length.\r\n     * @type {number}\r\n     */\r\n    this.len = 0;\r\n\r\n    /**\r\n     * Operations head.\r\n     * @type {Object}\r\n     */\r\n    this.head = new Op(noop, 0, 0);\r\n\r\n    /**\r\n     * Operations tail\r\n     * @type {Object}\r\n     */\r\n    this.tail = this.head;\r\n\r\n    /**\r\n     * Linked forked states.\r\n     * @type {Object|null}\r\n     */\r\n    this.states = null;\r\n\r\n    // When a value is written, the writer calculates its byte length and puts it into a linked\r\n    // list of operations to perform when finish() is called. This both allows us to allocate\r\n    // buffers of the exact required size and reduces the amount of work we have to do compared\r\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\r\n    // part is just a linked list walk calling operations with already prepared values.\r\n}\r\n\r\n/**\r\n * Creates a new writer.\r\n * @function\r\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\r\n */\r\nWriter.create = util.Buffer\r\n    ? function create_buffer_setup() {\r\n        return (Writer.create = function create_buffer() {\r\n            return new BufferWriter();\r\n        })();\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array() {\r\n        return new Writer();\r\n    };\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\nWriter.alloc = function alloc(size) {\r\n    return new util.Array(size);\r\n};\r\n\r\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\r\n/* istanbul ignore else */\r\nif (util.Array !== Array)\r\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\r\n\r\n/**\r\n * Pushes a new operation to the queue.\r\n * @param {function(Uint8Array, number, *)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @returns {Writer} `this`\r\n * @private\r\n */\r\nWriter.prototype._push = function push(fn, len, val) {\r\n    this.tail = this.tail.next = new Op(fn, len, val);\r\n    this.len += len;\r\n    return this;\r\n};\r\n\r\nfunction writeByte(val, buf, pos) {\r\n    buf[pos] = val & 255;\r\n}\r\n\r\nfunction writeVarint32(val, buf, pos) {\r\n    while (val > 127) {\r\n        buf[pos++] = val & 127 | 128;\r\n        val >>>= 7;\r\n    }\r\n    buf[pos] = val;\r\n}\r\n\r\n/**\r\n * Constructs a new varint writer operation instance.\r\n * @classdesc Scheduled varint writer operation.\r\n * @extends Op\r\n * @constructor\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @ignore\r\n */\r\nfunction VarintOp(len, val) {\r\n    this.len = len;\r\n    this.next = undefined;\r\n    this.val = val;\r\n}\r\n\r\nVarintOp.prototype = Object.create(Op.prototype);\r\nVarintOp.prototype.fn = writeVarint32;\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as a varint.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.uint32 = function write_uint32(value) {\r\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\r\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\r\n    this.len += (this.tail = this.tail.next = new VarintOp(\r\n        (value = value >>> 0)\r\n                < 128       ? 1\r\n        : value < 16384     ? 2\r\n        : value < 2097152   ? 3\r\n        : value < 268435456 ? 4\r\n        :                     5,\r\n    value)).len;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as a varint.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.int32 = function write_int32(value) {\r\n    return value < 0\r\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\r\n        : this.uint32(value);\r\n};\r\n\r\n/**\r\n * Writes a 32 bit value as a varint, zig-zag encoded.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sint32 = function write_sint32(value) {\r\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\r\n};\r\n\r\nfunction writeVarint64(val, buf, pos) {\r\n    while (val.hi) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\r\n        val.hi >>>= 7;\r\n    }\r\n    while (val.lo > 127) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = val.lo >>> 7;\r\n    }\r\n    buf[pos++] = val.lo;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as a varint.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.uint64 = function write_uint64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.int64 = Writer.prototype.uint64;\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sint64 = function write_sint64(value) {\r\n    var bits = LongBits.from(value).zzEncode();\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a boolish value as a varint.\r\n * @param {boolean} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bool = function write_bool(value) {\r\n    return this._push(writeByte, 1, value ? 1 : 0);\r\n};\r\n\r\nfunction writeFixed32(val, buf, pos) {\r\n    buf[pos    ] =  val         & 255;\r\n    buf[pos + 1] =  val >>> 8   & 255;\r\n    buf[pos + 2] =  val >>> 16  & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as fixed 32 bits.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fixed32 = function write_fixed32(value) {\r\n    return this._push(writeFixed32, 4, value >>> 0);\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as fixed 32 bits.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as fixed 64 bits.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.fixed64 = function write_fixed64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as fixed 64 bits.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\r\n\r\n/**\r\n * Writes a float (32 bit).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.float = function write_float(value) {\r\n    return this._push(util.float.writeFloatLE, 4, value);\r\n};\r\n\r\n/**\r\n * Writes a double (64 bit float).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.double = function write_double(value) {\r\n    return this._push(util.float.writeDoubleLE, 8, value);\r\n};\r\n\r\nvar writeBytes = util.Array.prototype.set\r\n    ? function writeBytes_set(val, buf, pos) {\r\n        buf.set(val, pos); // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytes_for(val, buf, pos) {\r\n        for (var i = 0; i < val.length; ++i)\r\n            buf[pos + i] = val[i];\r\n    };\r\n\r\n/**\r\n * Writes a sequence of bytes.\r\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bytes = function write_bytes(value) {\r\n    var len = value.length >>> 0;\r\n    if (!len)\r\n        return this._push(writeByte, 1, 0);\r\n    if (util.isString(value)) {\r\n        var buf = Writer.alloc(len = base64.length(value));\r\n        base64.decode(value, buf, 0);\r\n        value = buf;\r\n    }\r\n    return this.uint32(len)._push(writeBytes, len, value);\r\n};\r\n\r\n/**\r\n * Writes a string.\r\n * @param {string} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.string = function write_string(value) {\r\n    var len = utf8.length(value);\r\n    return len\r\n        ? this.uint32(len)._push(utf8.write, len, value)\r\n        : this._push(writeByte, 1, 0);\r\n};\r\n\r\n/**\r\n * Forks this writer's state by pushing it to a stack.\r\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fork = function fork() {\r\n    this.states = new State(this);\r\n    this.head = this.tail = new Op(noop, 0, 0);\r\n    this.len = 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets this instance to the last state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.reset = function reset() {\r\n    if (this.states) {\r\n        this.head   = this.states.head;\r\n        this.tail   = this.states.tail;\r\n        this.len    = this.states.len;\r\n        this.states = this.states.next;\r\n    } else {\r\n        this.head = this.tail = new Op(noop, 0, 0);\r\n        this.len  = 0;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.ldelim = function ldelim() {\r\n    var head = this.head,\r\n        tail = this.tail,\r\n        len  = this.len;\r\n    this.reset().uint32(len);\r\n    if (len) {\r\n        this.tail.next = head.next; // skip noop\r\n        this.tail = tail;\r\n        this.len += len;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @returns {Uint8Array} Finished buffer\r\n */\r\nWriter.prototype.finish = function finish() {\r\n    var head = this.head.next, // skip noop\r\n        buf  = this.constructor.alloc(this.len),\r\n        pos  = 0;\r\n    while (head) {\r\n        head.fn(head.val, buf, pos);\r\n        pos += head.len;\r\n        head = head.next;\r\n    }\r\n    // this.head = this.tail = null;\r\n    return buf;\r\n};\r\n\r\nWriter._configure = function(BufferWriter_) {\r\n    BufferWriter = BufferWriter_;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0dBQWdCO0FBQ3hDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQixHQUFHLG9CQUFvQix5Q0FBeUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxRQUFRO0FBQ3JCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsUUFBUTtBQUNyQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCLElBQUksNEJBQTRCO0FBQ3RFLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xyXG5cclxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xyXG5cclxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXHJcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcclxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxyXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5mbiA9IGZuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IGxlbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxyXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxyXG4gICAgICogQHR5cGUgeyp9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xyXG59XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXHJcbiAqIEBtZW1iZXJvZiBXcml0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgaGVhZC5cclxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCB0YWlsLlxyXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZXh0IHN0YXRlLlxyXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gV3JpdGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxyXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XHJcblxyXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxyXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcclxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcclxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcclxuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxyXG4gKi9cclxuV3JpdGVyLmNyZWF0ZSA9IHV0aWwuQnVmZmVyXHJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XHJcbiAgICB9O1xyXG5cclxuLyoqXHJcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcclxuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcclxufTtcclxuXHJcbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXHJcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XHJcblxyXG4vKipcclxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcclxuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XHJcbiAgICB0aGlzLmxlbiArPSBsZW47XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XHJcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcclxuICAgICAgICB2YWwgPj4+PSA3O1xyXG4gICAgfVxyXG4gICAgYnVmW3Bvc10gPSB2YWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cclxuICogQGV4dGVuZHMgT3BcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xyXG4gICAgdGhpcy5sZW4gPSBsZW47XHJcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnZhbCA9IHZhbDtcclxufVxyXG5cclxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xyXG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XHJcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cclxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXHJcbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXHJcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXHJcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcclxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXHJcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcclxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcclxuICAgIHZhbHVlKSkubGVuO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlIDwgMFxyXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXHJcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICB3aGlsZSAodmFsLmhpKSB7XHJcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcclxuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcclxuICAgICAgICB2YWwuaGkgPj4+PSA3O1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xyXG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XHJcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xyXG4gICAgfVxyXG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcclxufVxyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XHJcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XHJcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcclxuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XHJcbn07XHJcblxyXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxyXG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XHJcbiAgICB9O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XHJcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKCFsZW4pXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xyXG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XHJcbiAgICAgICAgdmFsdWUgPSBidWY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XHJcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xyXG4gICAgcmV0dXJuIGxlblxyXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxyXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxyXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XHJcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcclxuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcclxuICAgIHRoaXMubGVuID0gMDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgIGlmICh0aGlzLnN0YXRlcykge1xyXG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcclxuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XHJcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xyXG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXHJcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcclxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XHJcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XHJcbiAgICBpZiAobGVuKSB7XHJcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxyXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XHJcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XHJcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcclxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXHJcbiAgICAgICAgcG9zICA9IDA7XHJcbiAgICB3aGlsZSAoaGVhZCkge1xyXG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcclxuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XHJcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcclxuICAgIH1cclxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICByZXR1cm4gYnVmO1xyXG59O1xyXG5cclxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XHJcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/writer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/writer_buffer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/libsignal/node_modules/protobufjs/src/writer_buffer.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = BufferWriter;\r\n\r\n// extends Writer\r\nvar Writer = __webpack_require__(/*! ./writer */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/writer.js\");\r\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar Buffer = util.Buffer;\r\n\r\n/**\r\n * Constructs a new buffer writer instance.\r\n * @classdesc Wire format writer using node buffers.\r\n * @extends Writer\r\n * @constructor\r\n */\r\nfunction BufferWriter() {\r\n    Writer.call(this);\r\n}\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Buffer} Buffer\r\n */\r\nBufferWriter.alloc = function alloc_buffer(size) {\r\n    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);\r\n};\r\n\r\nvar writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === \"set\"\r\n    ? function writeBytesBuffer_set(val, buf, pos) {\r\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\r\n                           // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytesBuffer_copy(val, buf, pos) {\r\n        if (val.copy) // Buffer values\r\n            val.copy(buf, pos, 0, val.length);\r\n        else for (var i = 0; i < val.length;) // plain array values\r\n            buf[pos++] = val[i++];\r\n    };\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\r\n    if (util.isString(value))\r\n        value = util._Buffer_from(value, \"base64\");\r\n    var len = value.length >>> 0;\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeBytesBuffer, len, value);\r\n    return this;\r\n};\r\n\r\nfunction writeStringBuffer(val, buf, pos) {\r\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\r\n        util.utf8.write(val, buf, pos);\r\n    else\r\n        buf.utf8Write(val, pos);\r\n}\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.string = function write_string_buffer(value) {\r\n    var len = Buffer.byteLength(value);\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeStringBuffer, len, value);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @name BufferWriter#finish\r\n * @function\r\n * @returns {Buffer} Finished buffer\r\n */\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNGQUFVO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsa0dBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xyXG5cclxuLy8gZXh0ZW5kcyBXcml0ZXJcclxudmFyIFdyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcclxuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxudmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHdyaXRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxyXG4gKiBAZXh0ZW5kcyBXcml0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XHJcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlclxyXG4gKi9cclxuQnVmZmVyV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2NfYnVmZmVyKHNpemUpIHtcclxuICAgIHJldHVybiAoQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKShzaXplKTtcclxufTtcclxuXHJcbnZhciB3cml0ZUJ5dGVzQnVmZmVyID0gQnVmZmVyICYmIEJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIEJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCJcclxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xyXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcclxuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcclxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcclxuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XHJcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xyXG4gICAgaWYgKGxlbilcclxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcclxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xyXG4gICAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcclxuICAgIHRoaXMudWludDMyKGxlbik7XHJcbiAgICBpZiAobGVuKVxyXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXHJcbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEZpbmlzaGVkIGJ1ZmZlclxyXG4gKi9cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/node_modules/protobufjs/src/writer_buffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/WhisperTextProtocol.js":
/*!***********************************************************!*\
  !*** ./node_modules/libsignal/src/WhisperTextProtocol.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\n\nvar $protobuf = __webpack_require__(/*! protobufjs/minimal */ \"(rsc)/./node_modules/libsignal/node_modules/protobufjs/minimal.js\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.textsecure = (function() {\n\n    /**\n     * Namespace textsecure.\n     * @exports textsecure\n     * @namespace\n     */\n    var textsecure = {};\n\n    textsecure.WhisperMessage = (function() {\n\n        /**\n         * Properties of a WhisperMessage.\n         * @memberof textsecure\n         * @interface IWhisperMessage\n         * @property {Uint8Array|null} [ephemeralKey] WhisperMessage ephemeralKey\n         * @property {number|null} [counter] WhisperMessage counter\n         * @property {number|null} [previousCounter] WhisperMessage previousCounter\n         * @property {Uint8Array|null} [ciphertext] WhisperMessage ciphertext\n         */\n\n        /**\n         * Constructs a new WhisperMessage.\n         * @memberof textsecure\n         * @classdesc Represents a WhisperMessage.\n         * @implements IWhisperMessage\n         * @constructor\n         * @param {textsecure.IWhisperMessage=} [properties] Properties to set\n         */\n        function WhisperMessage(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * WhisperMessage ephemeralKey.\n         * @member {Uint8Array} ephemeralKey\n         * @memberof textsecure.WhisperMessage\n         * @instance\n         */\n        WhisperMessage.prototype.ephemeralKey = $util.newBuffer([]);\n\n        /**\n         * WhisperMessage counter.\n         * @member {number} counter\n         * @memberof textsecure.WhisperMessage\n         * @instance\n         */\n        WhisperMessage.prototype.counter = 0;\n\n        /**\n         * WhisperMessage previousCounter.\n         * @member {number} previousCounter\n         * @memberof textsecure.WhisperMessage\n         * @instance\n         */\n        WhisperMessage.prototype.previousCounter = 0;\n\n        /**\n         * WhisperMessage ciphertext.\n         * @member {Uint8Array} ciphertext\n         * @memberof textsecure.WhisperMessage\n         * @instance\n         */\n        WhisperMessage.prototype.ciphertext = $util.newBuffer([]);\n\n        /**\n         * Creates a new WhisperMessage instance using the specified properties.\n         * @function create\n         * @memberof textsecure.WhisperMessage\n         * @static\n         * @param {textsecure.IWhisperMessage=} [properties] Properties to set\n         * @returns {textsecure.WhisperMessage} WhisperMessage instance\n         */\n        WhisperMessage.create = function create(properties) {\n            return new WhisperMessage(properties);\n        };\n\n        /**\n         * Encodes the specified WhisperMessage message. Does not implicitly {@link textsecure.WhisperMessage.verify|verify} messages.\n         * @function encode\n         * @memberof textsecure.WhisperMessage\n         * @static\n         * @param {textsecure.IWhisperMessage} message WhisperMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WhisperMessage.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.ephemeralKey != null && message.hasOwnProperty(\"ephemeralKey\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeralKey);\n            if (message.counter != null && message.hasOwnProperty(\"counter\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.counter);\n            if (message.previousCounter != null && message.hasOwnProperty(\"previousCounter\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.previousCounter);\n            if (message.ciphertext != null && message.hasOwnProperty(\"ciphertext\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ciphertext);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified WhisperMessage message, length delimited. Does not implicitly {@link textsecure.WhisperMessage.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof textsecure.WhisperMessage\n         * @static\n         * @param {textsecure.IWhisperMessage} message WhisperMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WhisperMessage.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a WhisperMessage message from the specified reader or buffer.\n         * @function decode\n         * @memberof textsecure.WhisperMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {textsecure.WhisperMessage} WhisperMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WhisperMessage.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.textsecure.WhisperMessage();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.ephemeralKey = reader.bytes();\n                    break;\n                case 2:\n                    message.counter = reader.uint32();\n                    break;\n                case 3:\n                    message.previousCounter = reader.uint32();\n                    break;\n                case 4:\n                    message.ciphertext = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a WhisperMessage message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof textsecure.WhisperMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {textsecure.WhisperMessage} WhisperMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WhisperMessage.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a WhisperMessage message.\n         * @function verify\n         * @memberof textsecure.WhisperMessage\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        WhisperMessage.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.ephemeralKey != null && message.hasOwnProperty(\"ephemeralKey\"))\n                if (!(message.ephemeralKey && typeof message.ephemeralKey.length === \"number\" || $util.isString(message.ephemeralKey)))\n                    return \"ephemeralKey: buffer expected\";\n            if (message.counter != null && message.hasOwnProperty(\"counter\"))\n                if (!$util.isInteger(message.counter))\n                    return \"counter: integer expected\";\n            if (message.previousCounter != null && message.hasOwnProperty(\"previousCounter\"))\n                if (!$util.isInteger(message.previousCounter))\n                    return \"previousCounter: integer expected\";\n            if (message.ciphertext != null && message.hasOwnProperty(\"ciphertext\"))\n                if (!(message.ciphertext && typeof message.ciphertext.length === \"number\" || $util.isString(message.ciphertext)))\n                    return \"ciphertext: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a WhisperMessage message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof textsecure.WhisperMessage\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {textsecure.WhisperMessage} WhisperMessage\n         */\n        WhisperMessage.fromObject = function fromObject(object) {\n            if (object instanceof $root.textsecure.WhisperMessage)\n                return object;\n            var message = new $root.textsecure.WhisperMessage();\n            if (object.ephemeralKey != null)\n                if (typeof object.ephemeralKey === \"string\")\n                    $util.base64.decode(object.ephemeralKey, message.ephemeralKey = $util.newBuffer($util.base64.length(object.ephemeralKey)), 0);\n                else if (object.ephemeralKey.length)\n                    message.ephemeralKey = object.ephemeralKey;\n            if (object.counter != null)\n                message.counter = object.counter >>> 0;\n            if (object.previousCounter != null)\n                message.previousCounter = object.previousCounter >>> 0;\n            if (object.ciphertext != null)\n                if (typeof object.ciphertext === \"string\")\n                    $util.base64.decode(object.ciphertext, message.ciphertext = $util.newBuffer($util.base64.length(object.ciphertext)), 0);\n                else if (object.ciphertext.length)\n                    message.ciphertext = object.ciphertext;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a WhisperMessage message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof textsecure.WhisperMessage\n         * @static\n         * @param {textsecure.WhisperMessage} message WhisperMessage\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        WhisperMessage.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.ephemeralKey = \"\";\n                else {\n                    object.ephemeralKey = [];\n                    if (options.bytes !== Array)\n                        object.ephemeralKey = $util.newBuffer(object.ephemeralKey);\n                }\n                object.counter = 0;\n                object.previousCounter = 0;\n                if (options.bytes === String)\n                    object.ciphertext = \"\";\n                else {\n                    object.ciphertext = [];\n                    if (options.bytes !== Array)\n                        object.ciphertext = $util.newBuffer(object.ciphertext);\n                }\n            }\n            if (message.ephemeralKey != null && message.hasOwnProperty(\"ephemeralKey\"))\n                object.ephemeralKey = options.bytes === String ? $util.base64.encode(message.ephemeralKey, 0, message.ephemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralKey) : message.ephemeralKey;\n            if (message.counter != null && message.hasOwnProperty(\"counter\"))\n                object.counter = message.counter;\n            if (message.previousCounter != null && message.hasOwnProperty(\"previousCounter\"))\n                object.previousCounter = message.previousCounter;\n            if (message.ciphertext != null && message.hasOwnProperty(\"ciphertext\"))\n                object.ciphertext = options.bytes === String ? $util.base64.encode(message.ciphertext, 0, message.ciphertext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ciphertext) : message.ciphertext;\n            return object;\n        };\n\n        /**\n         * Converts this WhisperMessage to JSON.\n         * @function toJSON\n         * @memberof textsecure.WhisperMessage\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        WhisperMessage.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return WhisperMessage;\n    })();\n\n    textsecure.PreKeyWhisperMessage = (function() {\n\n        /**\n         * Properties of a PreKeyWhisperMessage.\n         * @memberof textsecure\n         * @interface IPreKeyWhisperMessage\n         * @property {number|null} [registrationId] PreKeyWhisperMessage registrationId\n         * @property {number|null} [preKeyId] PreKeyWhisperMessage preKeyId\n         * @property {number|null} [signedPreKeyId] PreKeyWhisperMessage signedPreKeyId\n         * @property {Uint8Array|null} [baseKey] PreKeyWhisperMessage baseKey\n         * @property {Uint8Array|null} [identityKey] PreKeyWhisperMessage identityKey\n         * @property {Uint8Array|null} [message] PreKeyWhisperMessage message\n         */\n\n        /**\n         * Constructs a new PreKeyWhisperMessage.\n         * @memberof textsecure\n         * @classdesc Represents a PreKeyWhisperMessage.\n         * @implements IPreKeyWhisperMessage\n         * @constructor\n         * @param {textsecure.IPreKeyWhisperMessage=} [properties] Properties to set\n         */\n        function PreKeyWhisperMessage(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * PreKeyWhisperMessage registrationId.\n         * @member {number} registrationId\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @instance\n         */\n        PreKeyWhisperMessage.prototype.registrationId = 0;\n\n        /**\n         * PreKeyWhisperMessage preKeyId.\n         * @member {number} preKeyId\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @instance\n         */\n        PreKeyWhisperMessage.prototype.preKeyId = 0;\n\n        /**\n         * PreKeyWhisperMessage signedPreKeyId.\n         * @member {number} signedPreKeyId\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @instance\n         */\n        PreKeyWhisperMessage.prototype.signedPreKeyId = 0;\n\n        /**\n         * PreKeyWhisperMessage baseKey.\n         * @member {Uint8Array} baseKey\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @instance\n         */\n        PreKeyWhisperMessage.prototype.baseKey = $util.newBuffer([]);\n\n        /**\n         * PreKeyWhisperMessage identityKey.\n         * @member {Uint8Array} identityKey\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @instance\n         */\n        PreKeyWhisperMessage.prototype.identityKey = $util.newBuffer([]);\n\n        /**\n         * PreKeyWhisperMessage message.\n         * @member {Uint8Array} message\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @instance\n         */\n        PreKeyWhisperMessage.prototype.message = $util.newBuffer([]);\n\n        /**\n         * Creates a new PreKeyWhisperMessage instance using the specified properties.\n         * @function create\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @static\n         * @param {textsecure.IPreKeyWhisperMessage=} [properties] Properties to set\n         * @returns {textsecure.PreKeyWhisperMessage} PreKeyWhisperMessage instance\n         */\n        PreKeyWhisperMessage.create = function create(properties) {\n            return new PreKeyWhisperMessage(properties);\n        };\n\n        /**\n         * Encodes the specified PreKeyWhisperMessage message. Does not implicitly {@link textsecure.PreKeyWhisperMessage.verify|verify} messages.\n         * @function encode\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @static\n         * @param {textsecure.IPreKeyWhisperMessage} message PreKeyWhisperMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PreKeyWhisperMessage.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.preKeyId != null && message.hasOwnProperty(\"preKeyId\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.preKeyId);\n            if (message.baseKey != null && message.hasOwnProperty(\"baseKey\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.baseKey);\n            if (message.identityKey != null && message.hasOwnProperty(\"identityKey\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.identityKey);\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.message);\n            if (message.registrationId != null && message.hasOwnProperty(\"registrationId\"))\n                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.registrationId);\n            if (message.signedPreKeyId != null && message.hasOwnProperty(\"signedPreKeyId\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.signedPreKeyId);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified PreKeyWhisperMessage message, length delimited. Does not implicitly {@link textsecure.PreKeyWhisperMessage.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @static\n         * @param {textsecure.IPreKeyWhisperMessage} message PreKeyWhisperMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PreKeyWhisperMessage.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a PreKeyWhisperMessage message from the specified reader or buffer.\n         * @function decode\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {textsecure.PreKeyWhisperMessage} PreKeyWhisperMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PreKeyWhisperMessage.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.textsecure.PreKeyWhisperMessage();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 5:\n                    message.registrationId = reader.uint32();\n                    break;\n                case 1:\n                    message.preKeyId = reader.uint32();\n                    break;\n                case 6:\n                    message.signedPreKeyId = reader.uint32();\n                    break;\n                case 2:\n                    message.baseKey = reader.bytes();\n                    break;\n                case 3:\n                    message.identityKey = reader.bytes();\n                    break;\n                case 4:\n                    message.message = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a PreKeyWhisperMessage message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {textsecure.PreKeyWhisperMessage} PreKeyWhisperMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PreKeyWhisperMessage.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a PreKeyWhisperMessage message.\n         * @function verify\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        PreKeyWhisperMessage.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.registrationId != null && message.hasOwnProperty(\"registrationId\"))\n                if (!$util.isInteger(message.registrationId))\n                    return \"registrationId: integer expected\";\n            if (message.preKeyId != null && message.hasOwnProperty(\"preKeyId\"))\n                if (!$util.isInteger(message.preKeyId))\n                    return \"preKeyId: integer expected\";\n            if (message.signedPreKeyId != null && message.hasOwnProperty(\"signedPreKeyId\"))\n                if (!$util.isInteger(message.signedPreKeyId))\n                    return \"signedPreKeyId: integer expected\";\n            if (message.baseKey != null && message.hasOwnProperty(\"baseKey\"))\n                if (!(message.baseKey && typeof message.baseKey.length === \"number\" || $util.isString(message.baseKey)))\n                    return \"baseKey: buffer expected\";\n            if (message.identityKey != null && message.hasOwnProperty(\"identityKey\"))\n                if (!(message.identityKey && typeof message.identityKey.length === \"number\" || $util.isString(message.identityKey)))\n                    return \"identityKey: buffer expected\";\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                if (!(message.message && typeof message.message.length === \"number\" || $util.isString(message.message)))\n                    return \"message: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a PreKeyWhisperMessage message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {textsecure.PreKeyWhisperMessage} PreKeyWhisperMessage\n         */\n        PreKeyWhisperMessage.fromObject = function fromObject(object) {\n            if (object instanceof $root.textsecure.PreKeyWhisperMessage)\n                return object;\n            var message = new $root.textsecure.PreKeyWhisperMessage();\n            if (object.registrationId != null)\n                message.registrationId = object.registrationId >>> 0;\n            if (object.preKeyId != null)\n                message.preKeyId = object.preKeyId >>> 0;\n            if (object.signedPreKeyId != null)\n                message.signedPreKeyId = object.signedPreKeyId >>> 0;\n            if (object.baseKey != null)\n                if (typeof object.baseKey === \"string\")\n                    $util.base64.decode(object.baseKey, message.baseKey = $util.newBuffer($util.base64.length(object.baseKey)), 0);\n                else if (object.baseKey.length)\n                    message.baseKey = object.baseKey;\n            if (object.identityKey != null)\n                if (typeof object.identityKey === \"string\")\n                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);\n                else if (object.identityKey.length)\n                    message.identityKey = object.identityKey;\n            if (object.message != null)\n                if (typeof object.message === \"string\")\n                    $util.base64.decode(object.message, message.message = $util.newBuffer($util.base64.length(object.message)), 0);\n                else if (object.message.length)\n                    message.message = object.message;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a PreKeyWhisperMessage message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @static\n         * @param {textsecure.PreKeyWhisperMessage} message PreKeyWhisperMessage\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        PreKeyWhisperMessage.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.preKeyId = 0;\n                if (options.bytes === String)\n                    object.baseKey = \"\";\n                else {\n                    object.baseKey = [];\n                    if (options.bytes !== Array)\n                        object.baseKey = $util.newBuffer(object.baseKey);\n                }\n                if (options.bytes === String)\n                    object.identityKey = \"\";\n                else {\n                    object.identityKey = [];\n                    if (options.bytes !== Array)\n                        object.identityKey = $util.newBuffer(object.identityKey);\n                }\n                if (options.bytes === String)\n                    object.message = \"\";\n                else {\n                    object.message = [];\n                    if (options.bytes !== Array)\n                        object.message = $util.newBuffer(object.message);\n                }\n                object.registrationId = 0;\n                object.signedPreKeyId = 0;\n            }\n            if (message.preKeyId != null && message.hasOwnProperty(\"preKeyId\"))\n                object.preKeyId = message.preKeyId;\n            if (message.baseKey != null && message.hasOwnProperty(\"baseKey\"))\n                object.baseKey = options.bytes === String ? $util.base64.encode(message.baseKey, 0, message.baseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKey) : message.baseKey;\n            if (message.identityKey != null && message.hasOwnProperty(\"identityKey\"))\n                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                object.message = options.bytes === String ? $util.base64.encode(message.message, 0, message.message.length) : options.bytes === Array ? Array.prototype.slice.call(message.message) : message.message;\n            if (message.registrationId != null && message.hasOwnProperty(\"registrationId\"))\n                object.registrationId = message.registrationId;\n            if (message.signedPreKeyId != null && message.hasOwnProperty(\"signedPreKeyId\"))\n                object.signedPreKeyId = message.signedPreKeyId;\n            return object;\n        };\n\n        /**\n         * Converts this PreKeyWhisperMessage to JSON.\n         * @function toJSON\n         * @memberof textsecure.PreKeyWhisperMessage\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        PreKeyWhisperMessage.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return PreKeyWhisperMessage;\n    })();\n\n    textsecure.KeyExchangeMessage = (function() {\n\n        /**\n         * Properties of a KeyExchangeMessage.\n         * @memberof textsecure\n         * @interface IKeyExchangeMessage\n         * @property {number|null} [id] KeyExchangeMessage id\n         * @property {Uint8Array|null} [baseKey] KeyExchangeMessage baseKey\n         * @property {Uint8Array|null} [ephemeralKey] KeyExchangeMessage ephemeralKey\n         * @property {Uint8Array|null} [identityKey] KeyExchangeMessage identityKey\n         * @property {Uint8Array|null} [baseKeySignature] KeyExchangeMessage baseKeySignature\n         */\n\n        /**\n         * Constructs a new KeyExchangeMessage.\n         * @memberof textsecure\n         * @classdesc Represents a KeyExchangeMessage.\n         * @implements IKeyExchangeMessage\n         * @constructor\n         * @param {textsecure.IKeyExchangeMessage=} [properties] Properties to set\n         */\n        function KeyExchangeMessage(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * KeyExchangeMessage id.\n         * @member {number} id\n         * @memberof textsecure.KeyExchangeMessage\n         * @instance\n         */\n        KeyExchangeMessage.prototype.id = 0;\n\n        /**\n         * KeyExchangeMessage baseKey.\n         * @member {Uint8Array} baseKey\n         * @memberof textsecure.KeyExchangeMessage\n         * @instance\n         */\n        KeyExchangeMessage.prototype.baseKey = $util.newBuffer([]);\n\n        /**\n         * KeyExchangeMessage ephemeralKey.\n         * @member {Uint8Array} ephemeralKey\n         * @memberof textsecure.KeyExchangeMessage\n         * @instance\n         */\n        KeyExchangeMessage.prototype.ephemeralKey = $util.newBuffer([]);\n\n        /**\n         * KeyExchangeMessage identityKey.\n         * @member {Uint8Array} identityKey\n         * @memberof textsecure.KeyExchangeMessage\n         * @instance\n         */\n        KeyExchangeMessage.prototype.identityKey = $util.newBuffer([]);\n\n        /**\n         * KeyExchangeMessage baseKeySignature.\n         * @member {Uint8Array} baseKeySignature\n         * @memberof textsecure.KeyExchangeMessage\n         * @instance\n         */\n        KeyExchangeMessage.prototype.baseKeySignature = $util.newBuffer([]);\n\n        /**\n         * Creates a new KeyExchangeMessage instance using the specified properties.\n         * @function create\n         * @memberof textsecure.KeyExchangeMessage\n         * @static\n         * @param {textsecure.IKeyExchangeMessage=} [properties] Properties to set\n         * @returns {textsecure.KeyExchangeMessage} KeyExchangeMessage instance\n         */\n        KeyExchangeMessage.create = function create(properties) {\n            return new KeyExchangeMessage(properties);\n        };\n\n        /**\n         * Encodes the specified KeyExchangeMessage message. Does not implicitly {@link textsecure.KeyExchangeMessage.verify|verify} messages.\n         * @function encode\n         * @memberof textsecure.KeyExchangeMessage\n         * @static\n         * @param {textsecure.IKeyExchangeMessage} message KeyExchangeMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        KeyExchangeMessage.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n            if (message.baseKey != null && message.hasOwnProperty(\"baseKey\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.baseKey);\n            if (message.ephemeralKey != null && message.hasOwnProperty(\"ephemeralKey\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ephemeralKey);\n            if (message.identityKey != null && message.hasOwnProperty(\"identityKey\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.identityKey);\n            if (message.baseKeySignature != null && message.hasOwnProperty(\"baseKeySignature\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.baseKeySignature);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified KeyExchangeMessage message, length delimited. Does not implicitly {@link textsecure.KeyExchangeMessage.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof textsecure.KeyExchangeMessage\n         * @static\n         * @param {textsecure.IKeyExchangeMessage} message KeyExchangeMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        KeyExchangeMessage.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a KeyExchangeMessage message from the specified reader or buffer.\n         * @function decode\n         * @memberof textsecure.KeyExchangeMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {textsecure.KeyExchangeMessage} KeyExchangeMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        KeyExchangeMessage.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.textsecure.KeyExchangeMessage();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint32();\n                    break;\n                case 2:\n                    message.baseKey = reader.bytes();\n                    break;\n                case 3:\n                    message.ephemeralKey = reader.bytes();\n                    break;\n                case 4:\n                    message.identityKey = reader.bytes();\n                    break;\n                case 5:\n                    message.baseKeySignature = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a KeyExchangeMessage message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof textsecure.KeyExchangeMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {textsecure.KeyExchangeMessage} KeyExchangeMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        KeyExchangeMessage.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a KeyExchangeMessage message.\n         * @function verify\n         * @memberof textsecure.KeyExchangeMessage\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        KeyExchangeMessage.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isInteger(message.id))\n                    return \"id: integer expected\";\n            if (message.baseKey != null && message.hasOwnProperty(\"baseKey\"))\n                if (!(message.baseKey && typeof message.baseKey.length === \"number\" || $util.isString(message.baseKey)))\n                    return \"baseKey: buffer expected\";\n            if (message.ephemeralKey != null && message.hasOwnProperty(\"ephemeralKey\"))\n                if (!(message.ephemeralKey && typeof message.ephemeralKey.length === \"number\" || $util.isString(message.ephemeralKey)))\n                    return \"ephemeralKey: buffer expected\";\n            if (message.identityKey != null && message.hasOwnProperty(\"identityKey\"))\n                if (!(message.identityKey && typeof message.identityKey.length === \"number\" || $util.isString(message.identityKey)))\n                    return \"identityKey: buffer expected\";\n            if (message.baseKeySignature != null && message.hasOwnProperty(\"baseKeySignature\"))\n                if (!(message.baseKeySignature && typeof message.baseKeySignature.length === \"number\" || $util.isString(message.baseKeySignature)))\n                    return \"baseKeySignature: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a KeyExchangeMessage message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof textsecure.KeyExchangeMessage\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {textsecure.KeyExchangeMessage} KeyExchangeMessage\n         */\n        KeyExchangeMessage.fromObject = function fromObject(object) {\n            if (object instanceof $root.textsecure.KeyExchangeMessage)\n                return object;\n            var message = new $root.textsecure.KeyExchangeMessage();\n            if (object.id != null)\n                message.id = object.id >>> 0;\n            if (object.baseKey != null)\n                if (typeof object.baseKey === \"string\")\n                    $util.base64.decode(object.baseKey, message.baseKey = $util.newBuffer($util.base64.length(object.baseKey)), 0);\n                else if (object.baseKey.length)\n                    message.baseKey = object.baseKey;\n            if (object.ephemeralKey != null)\n                if (typeof object.ephemeralKey === \"string\")\n                    $util.base64.decode(object.ephemeralKey, message.ephemeralKey = $util.newBuffer($util.base64.length(object.ephemeralKey)), 0);\n                else if (object.ephemeralKey.length)\n                    message.ephemeralKey = object.ephemeralKey;\n            if (object.identityKey != null)\n                if (typeof object.identityKey === \"string\")\n                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);\n                else if (object.identityKey.length)\n                    message.identityKey = object.identityKey;\n            if (object.baseKeySignature != null)\n                if (typeof object.baseKeySignature === \"string\")\n                    $util.base64.decode(object.baseKeySignature, message.baseKeySignature = $util.newBuffer($util.base64.length(object.baseKeySignature)), 0);\n                else if (object.baseKeySignature.length)\n                    message.baseKeySignature = object.baseKeySignature;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a KeyExchangeMessage message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof textsecure.KeyExchangeMessage\n         * @static\n         * @param {textsecure.KeyExchangeMessage} message KeyExchangeMessage\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        KeyExchangeMessage.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.id = 0;\n                if (options.bytes === String)\n                    object.baseKey = \"\";\n                else {\n                    object.baseKey = [];\n                    if (options.bytes !== Array)\n                        object.baseKey = $util.newBuffer(object.baseKey);\n                }\n                if (options.bytes === String)\n                    object.ephemeralKey = \"\";\n                else {\n                    object.ephemeralKey = [];\n                    if (options.bytes !== Array)\n                        object.ephemeralKey = $util.newBuffer(object.ephemeralKey);\n                }\n                if (options.bytes === String)\n                    object.identityKey = \"\";\n                else {\n                    object.identityKey = [];\n                    if (options.bytes !== Array)\n                        object.identityKey = $util.newBuffer(object.identityKey);\n                }\n                if (options.bytes === String)\n                    object.baseKeySignature = \"\";\n                else {\n                    object.baseKeySignature = [];\n                    if (options.bytes !== Array)\n                        object.baseKeySignature = $util.newBuffer(object.baseKeySignature);\n                }\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.baseKey != null && message.hasOwnProperty(\"baseKey\"))\n                object.baseKey = options.bytes === String ? $util.base64.encode(message.baseKey, 0, message.baseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKey) : message.baseKey;\n            if (message.ephemeralKey != null && message.hasOwnProperty(\"ephemeralKey\"))\n                object.ephemeralKey = options.bytes === String ? $util.base64.encode(message.ephemeralKey, 0, message.ephemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralKey) : message.ephemeralKey;\n            if (message.identityKey != null && message.hasOwnProperty(\"identityKey\"))\n                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;\n            if (message.baseKeySignature != null && message.hasOwnProperty(\"baseKeySignature\"))\n                object.baseKeySignature = options.bytes === String ? $util.base64.encode(message.baseKeySignature, 0, message.baseKeySignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKeySignature) : message.baseKeySignature;\n            return object;\n        };\n\n        /**\n         * Converts this KeyExchangeMessage to JSON.\n         * @function toJSON\n         * @memberof textsecure.KeyExchangeMessage\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        KeyExchangeMessage.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return KeyExchangeMessage;\n    })();\n\n    return textsecure;\n})();\n\nmodule.exports = $root;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9XaGlzcGVyVGV4dFByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsNkZBQW9COztBQUU1QztBQUNBOztBQUVBO0FBQ0EsMEVBQTBFOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHNCQUFzQixhQUFhO0FBQ25DLHNCQUFzQixhQUFhO0FBQ25DLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUJBQWlCO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSwrQ0FBK0M7QUFDN0g7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdHQUFnRywrQ0FBK0M7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLDJCQUEyQjtBQUNoRCxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRCxxQkFBcUIsMkJBQTJCO0FBQ2hELG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsOEJBQThCO0FBQ2pELHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DLHNCQUFzQixhQUFhO0FBQ25DLHNCQUFzQixhQUFhO0FBQ25DLHNCQUFzQixpQkFBaUI7QUFDdkMsc0JBQXNCLGlCQUFpQjtBQUN2QyxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRixxREFBcUQ7QUFDekk7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRCxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0dBQXNHLHFEQUFxRDtBQUMzSjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDO0FBQ3JELG1CQUFtQixrQkFBa0I7QUFDckMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRCxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsaUNBQWlDO0FBQ3RELG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELHFCQUFxQixpQ0FBaUM7QUFDdEQsb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQsbUJBQW1CLDhCQUE4QjtBQUNqRCxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQyxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHNCQUFzQixpQkFBaUI7QUFDdkMsc0JBQXNCLGlCQUFpQjtBQUN2QyxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRCxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWtGLG1EQUFtRDtBQUNySTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25ELG1CQUFtQixrQkFBa0I7QUFDckMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9HQUFvRyxtREFBbUQ7QUFDdko7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRCxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLCtCQUErQjtBQUNwRCxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRCxxQkFBcUIsK0JBQStCO0FBQ3BELG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLDhCQUE4QjtBQUNqRCxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvc3JjL1doaXNwZXJUZXh0UHJvdG9jb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyplc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBpZC1sZW5ndGgsIG5vLWNvbnRyb2wtcmVnZXgsIG5vLW1hZ2ljLW51bWJlcnMsIG5vLXByb3RvdHlwZS1idWlsdGlucywgbm8tcmVkZWNsYXJlLCBuby1zaGFkb3csIG5vLXZhciwgc29ydC12YXJzKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJHByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKTtcblxuLy8gQ29tbW9uIGFsaWFzZXNcbnZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlciwgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5cbi8vIEV4cG9ydGVkIHJvb3QgbmFtZXNwYWNlXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xuXG4kcm9vdC50ZXh0c2VjdXJlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIHRleHRzZWN1cmUuXG4gICAgICogQGV4cG9ydHMgdGV4dHNlY3VyZVxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICB2YXIgdGV4dHNlY3VyZSA9IHt9O1xuXG4gICAgdGV4dHNlY3VyZS5XaGlzcGVyTWVzc2FnZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFdoaXNwZXJNZXNzYWdlLlxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZVxuICAgICAgICAgKiBAaW50ZXJmYWNlIElXaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW2VwaGVtZXJhbEtleV0gV2hpc3Blck1lc3NhZ2UgZXBoZW1lcmFsS2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtjb3VudGVyXSBXaGlzcGVyTWVzc2FnZSBjb3VudGVyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtwcmV2aW91c0NvdW50ZXJdIFdoaXNwZXJNZXNzYWdlIHByZXZpb3VzQ291bnRlclxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW2NpcGhlcnRleHRdIFdoaXNwZXJNZXNzYWdlIGNpcGhlcnRleHRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgV2hpc3Blck1lc3NhZ2UuXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFdoaXNwZXJNZXNzYWdlLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJV2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7dGV4dHNlY3VyZS5JV2hpc3Blck1lc3NhZ2U9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFdoaXNwZXJNZXNzYWdlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpc3Blck1lc3NhZ2UgZXBoZW1lcmFsS2V5LlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBlcGhlbWVyYWxLZXlcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBXaGlzcGVyTWVzc2FnZS5wcm90b3R5cGUuZXBoZW1lcmFsS2V5ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpc3Blck1lc3NhZ2UgY291bnRlci5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBjb3VudGVyXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgV2hpc3Blck1lc3NhZ2UucHJvdG90eXBlLmNvdW50ZXIgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGlzcGVyTWVzc2FnZSBwcmV2aW91c0NvdW50ZXIuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gcHJldmlvdXNDb3VudGVyXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgV2hpc3Blck1lc3NhZ2UucHJvdG90eXBlLnByZXZpb3VzQ291bnRlciA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoaXNwZXJNZXNzYWdlIGNpcGhlcnRleHQuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IGNpcGhlcnRleHRcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBXaGlzcGVyTWVzc2FnZS5wcm90b3R5cGUuY2lwaGVydGV4dCA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgV2hpc3Blck1lc3NhZ2UgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHt0ZXh0c2VjdXJlLklXaGlzcGVyTWVzc2FnZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7dGV4dHNlY3VyZS5XaGlzcGVyTWVzc2FnZX0gV2hpc3Blck1lc3NhZ2UgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFdoaXNwZXJNZXNzYWdlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoaXNwZXJNZXNzYWdlKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgV2hpc3Blck1lc3NhZ2UgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgdGV4dHNlY3VyZS5XaGlzcGVyTWVzc2FnZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5XaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7dGV4dHNlY3VyZS5JV2hpc3Blck1lc3NhZ2V9IG1lc3NhZ2UgV2hpc3Blck1lc3NhZ2UgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBXaGlzcGVyTWVzc2FnZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXBoZW1lcmFsS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVwaGVtZXJhbEtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmJ5dGVzKG1lc3NhZ2UuZXBoZW1lcmFsS2V5KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmNvdW50ZXIgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY291bnRlclwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovMTYpLnVpbnQzMihtZXNzYWdlLmNvdW50ZXIpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJldmlvdXNDb3VudGVyICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByZXZpb3VzQ291bnRlclwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovMjQpLnVpbnQzMihtZXNzYWdlLnByZXZpb3VzQ291bnRlcik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jaXBoZXJ0ZXh0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNpcGhlcnRleHRcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5ieXRlcyhtZXNzYWdlLmNpcGhlcnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFdoaXNwZXJNZXNzYWdlIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIHRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2UudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3RleHRzZWN1cmUuSVdoaXNwZXJNZXNzYWdlfSBtZXNzYWdlIFdoaXNwZXJNZXNzYWdlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgV2hpc3Blck1lc3NhZ2UuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBXaGlzcGVyTWVzc2FnZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHt0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlfSBXaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFdoaXNwZXJNZXNzYWdlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcGhlbWVyYWxLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvdW50ZXIgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmV2aW91c0NvdW50ZXIgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBXaGlzcGVyTWVzc2FnZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHt0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlfSBXaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFdoaXNwZXJNZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFdoaXNwZXJNZXNzYWdlIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFdoaXNwZXJNZXNzYWdlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmVwaGVtZXJhbEtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlcGhlbWVyYWxLZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5lcGhlbWVyYWxLZXkgJiYgdHlwZW9mIG1lc3NhZ2UuZXBoZW1lcmFsS2V5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmVwaGVtZXJhbEtleSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlcGhlbWVyYWxLZXk6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY291bnRlciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjb3VudGVyXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuY291bnRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvdW50ZXI6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZXZpb3VzQ291bnRlciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmV2aW91c0NvdW50ZXJcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5wcmV2aW91c0NvdW50ZXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmV2aW91c0NvdW50ZXI6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmNpcGhlcnRleHQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2lwaGVydGV4dFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmNpcGhlcnRleHQgJiYgdHlwZW9mIG1lc3NhZ2UuY2lwaGVydGV4dC5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5jaXBoZXJ0ZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNpcGhlcnRleHQ6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBXaGlzcGVyTWVzc2FnZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7dGV4dHNlY3VyZS5XaGlzcGVyTWVzc2FnZX0gV2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICovXG4gICAgICAgIFdoaXNwZXJNZXNzYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LnRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LnRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2UoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZXBoZW1lcmFsS2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZXBoZW1lcmFsS2V5ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5lcGhlbWVyYWxLZXksIG1lc3NhZ2UuZXBoZW1lcmFsS2V5ID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LmVwaGVtZXJhbEtleSkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3QuZXBoZW1lcmFsS2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcGhlbWVyYWxLZXkgPSBvYmplY3QuZXBoZW1lcmFsS2V5O1xuICAgICAgICAgICAgaWYgKG9iamVjdC5jb3VudGVyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jb3VudGVyID0gb2JqZWN0LmNvdW50ZXIgPj4+IDA7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnByZXZpb3VzQ291bnRlciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJldmlvdXNDb3VudGVyID0gb2JqZWN0LnByZXZpb3VzQ291bnRlciA+Pj4gMDtcbiAgICAgICAgICAgIGlmIChvYmplY3QuY2lwaGVydGV4dCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmNpcGhlcnRleHQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LmNpcGhlcnRleHQsIG1lc3NhZ2UuY2lwaGVydGV4dCA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5jaXBoZXJ0ZXh0KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5jaXBoZXJ0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID0gb2JqZWN0LmNpcGhlcnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgV2hpc3Blck1lc3NhZ2UgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3RleHRzZWN1cmUuV2hpc3Blck1lc3NhZ2V9IG1lc3NhZ2UgV2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBXaGlzcGVyTWVzc2FnZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5lcGhlbWVyYWxLZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZXBoZW1lcmFsS2V5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5lcGhlbWVyYWxLZXkgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LmVwaGVtZXJhbEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdC5jb3VudGVyID0gMDtcbiAgICAgICAgICAgICAgICBvYmplY3QucHJldmlvdXNDb3VudGVyID0gMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuY2lwaGVydGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5jaXBoZXJ0ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5jaXBoZXJ0ZXh0ID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5jaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lcGhlbWVyYWxLZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXBoZW1lcmFsS2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5lcGhlbWVyYWxLZXkgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UuZXBoZW1lcmFsS2V5LCAwLCBtZXNzYWdlLmVwaGVtZXJhbEtleS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmVwaGVtZXJhbEtleSkgOiBtZXNzYWdlLmVwaGVtZXJhbEtleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmNvdW50ZXIgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY291bnRlclwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuY291bnRlciA9IG1lc3NhZ2UuY291bnRlcjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZXZpb3VzQ291bnRlciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmV2aW91c0NvdW50ZXJcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnByZXZpb3VzQ291bnRlciA9IG1lc3NhZ2UucHJldmlvdXNDb3VudGVyO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY2lwaGVydGV4dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaXBoZXJ0ZXh0XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5jaXBoZXJ0ZXh0ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmNpcGhlcnRleHQsIDAsIG1lc3NhZ2UuY2lwaGVydGV4dC5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmNpcGhlcnRleHQpIDogbWVzc2FnZS5jaXBoZXJ0ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBXaGlzcGVyTWVzc2FnZSB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLldoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBXaGlzcGVyTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFdoaXNwZXJNZXNzYWdlO1xuICAgIH0pKCk7XG5cbiAgICB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgUHJlS2V5V2hpc3Blck1lc3NhZ2UuXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtyZWdpc3RyYXRpb25JZF0gUHJlS2V5V2hpc3Blck1lc3NhZ2UgcmVnaXN0cmF0aW9uSWRcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3ByZUtleUlkXSBQcmVLZXlXaGlzcGVyTWVzc2FnZSBwcmVLZXlJZFxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbc2lnbmVkUHJlS2V5SWRdIFByZUtleVdoaXNwZXJNZXNzYWdlIHNpZ25lZFByZUtleUlkXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbYmFzZUtleV0gUHJlS2V5V2hpc3Blck1lc3NhZ2UgYmFzZUtleVxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW2lkZW50aXR5S2V5XSBQcmVLZXlXaGlzcGVyTWVzc2FnZSBpZGVudGl0eUtleVxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW21lc3NhZ2VdIFByZUtleVdoaXNwZXJNZXNzYWdlIG1lc3NhZ2VcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUHJlS2V5V2hpc3Blck1lc3NhZ2UuXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFByZUtleVdoaXNwZXJNZXNzYWdlLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJUHJlS2V5V2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7dGV4dHNlY3VyZS5JUHJlS2V5V2hpc3Blck1lc3NhZ2U9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFByZUtleVdoaXNwZXJNZXNzYWdlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJlS2V5V2hpc3Blck1lc3NhZ2UgcmVnaXN0cmF0aW9uSWQuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gcmVnaXN0cmF0aW9uSWRcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuUHJlS2V5V2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBQcmVLZXlXaGlzcGVyTWVzc2FnZS5wcm90b3R5cGUucmVnaXN0cmF0aW9uSWQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmVLZXlXaGlzcGVyTWVzc2FnZSBwcmVLZXlJZC5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBwcmVLZXlJZFxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5QcmVLZXlXaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFByZUtleVdoaXNwZXJNZXNzYWdlLnByb3RvdHlwZS5wcmVLZXlJZCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZUtleVdoaXNwZXJNZXNzYWdlIHNpZ25lZFByZUtleUlkLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHNpZ25lZFByZUtleUlkXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJlS2V5V2hpc3Blck1lc3NhZ2UucHJvdG90eXBlLnNpZ25lZFByZUtleUlkID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJlS2V5V2hpc3Blck1lc3NhZ2UgYmFzZUtleS5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0gYmFzZUtleVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5QcmVLZXlXaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFByZUtleVdoaXNwZXJNZXNzYWdlLnByb3RvdHlwZS5iYXNlS2V5ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJlS2V5V2hpc3Blck1lc3NhZ2UgaWRlbnRpdHlLZXkuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IGlkZW50aXR5S2V5XG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJlS2V5V2hpc3Blck1lc3NhZ2UucHJvdG90eXBlLmlkZW50aXR5S2V5ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJlS2V5V2hpc3Blck1lc3NhZ2UgbWVzc2FnZS5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0gbWVzc2FnZVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5QcmVLZXlXaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFByZUtleVdoaXNwZXJNZXNzYWdlLnByb3RvdHlwZS5tZXNzYWdlID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBQcmVLZXlXaGlzcGVyTWVzc2FnZSBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuUHJlS2V5V2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3RleHRzZWN1cmUuSVByZUtleVdoaXNwZXJNZXNzYWdlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHt0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlfSBQcmVLZXlXaGlzcGVyTWVzc2FnZSBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJlS2V5V2hpc3Blck1lc3NhZ2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJlS2V5V2hpc3Blck1lc3NhZ2UocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBQcmVLZXlXaGlzcGVyTWVzc2FnZSBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHt0ZXh0c2VjdXJlLklQcmVLZXlXaGlzcGVyTWVzc2FnZX0gbWVzc2FnZSBQcmVLZXlXaGlzcGVyTWVzc2FnZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFByZUtleVdoaXNwZXJNZXNzYWdlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVLZXlJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVLZXlJZFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkudWludDMyKG1lc3NhZ2UucHJlS2V5SWQpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmFzZUtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXNlS2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuYnl0ZXMobWVzc2FnZS5iYXNlS2V5KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlkZW50aXR5S2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlkZW50aXR5S2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuYnl0ZXMobWVzc2FnZS5pZGVudGl0eUtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1lc3NhZ2VcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5ieXRlcyhtZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVnaXN0cmF0aW9uSWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmVnaXN0cmF0aW9uSWRcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAwID0qLzQwKS51aW50MzIobWVzc2FnZS5yZWdpc3RyYXRpb25JZCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zaWduZWRQcmVLZXlJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzaWduZWRQcmVLZXlJZFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDAgPSovNDgpLnVpbnQzMihtZXNzYWdlLnNpZ25lZFByZUtleUlkKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBQcmVLZXlXaGlzcGVyTWVzc2FnZSBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHt0ZXh0c2VjdXJlLklQcmVLZXlXaGlzcGVyTWVzc2FnZX0gbWVzc2FnZSBQcmVLZXlXaGlzcGVyTWVzc2FnZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFByZUtleVdoaXNwZXJNZXNzYWdlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgUHJlS2V5V2hpc3Blck1lc3NhZ2UgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5QcmVLZXlXaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7dGV4dHNlY3VyZS5QcmVLZXlXaGlzcGVyTWVzc2FnZX0gUHJlS2V5V2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBQcmVLZXlXaGlzcGVyTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC50ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVnaXN0cmF0aW9uSWQgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVLZXlJZCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25lZFByZUtleUlkID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmFzZUtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFByZUtleVdoaXNwZXJNZXNzYWdlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuUHJlS2V5V2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge3RleHRzZWN1cmUuUHJlS2V5V2hpc3Blck1lc3NhZ2V9IFByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgUHJlS2V5V2hpc3Blck1lc3NhZ2UuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgUHJlS2V5V2hpc3Blck1lc3NhZ2UgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5QcmVLZXlXaGlzcGVyTWVzc2FnZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgUHJlS2V5V2hpc3Blck1lc3NhZ2UudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVnaXN0cmF0aW9uSWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmVnaXN0cmF0aW9uSWRcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5yZWdpc3RyYXRpb25JZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJlZ2lzdHJhdGlvbklkOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVLZXlJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVLZXlJZFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnByZUtleUlkKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicHJlS2V5SWQ6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNpZ25lZFByZUtleUlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNpZ25lZFByZUtleUlkXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2Uuc2lnbmVkUHJlS2V5SWQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWduZWRQcmVLZXlJZDogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmFzZUtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXNlS2V5XCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuYmFzZUtleSAmJiB0eXBlb2YgbWVzc2FnZS5iYXNlS2V5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmJhc2VLZXkpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYmFzZUtleTogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eUtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZGVudGl0eUtleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmlkZW50aXR5S2V5ICYmIHR5cGVvZiBtZXNzYWdlLmlkZW50aXR5S2V5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmlkZW50aXR5S2V5KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlkZW50aXR5S2V5OiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UubWVzc2FnZS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5tZXNzYWdlKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1lc3NhZ2U6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBQcmVLZXlXaGlzcGVyTWVzc2FnZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7dGV4dHNlY3VyZS5QcmVLZXlXaGlzcGVyTWVzc2FnZX0gUHJlS2V5V2hpc3Blck1lc3NhZ2VcbiAgICAgICAgICovXG4gICAgICAgIFByZUtleVdoaXNwZXJNZXNzYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LnRleHRzZWN1cmUuUHJlS2V5V2hpc3Blck1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LnRleHRzZWN1cmUuUHJlS2V5V2hpc3Blck1lc3NhZ2UoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVnaXN0cmF0aW9uSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlZ2lzdHJhdGlvbklkID0gb2JqZWN0LnJlZ2lzdHJhdGlvbklkID4+PiAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5wcmVLZXlJZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlS2V5SWQgPSBvYmplY3QucHJlS2V5SWQgPj4+IDA7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnNpZ25lZFByZUtleUlkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduZWRQcmVLZXlJZCA9IG9iamVjdC5zaWduZWRQcmVLZXlJZCA+Pj4gMDtcbiAgICAgICAgICAgIGlmIChvYmplY3QuYmFzZUtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmJhc2VLZXkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LmJhc2VLZXksIG1lc3NhZ2UuYmFzZUtleSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5iYXNlS2V5KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5iYXNlS2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iYXNlS2V5ID0gb2JqZWN0LmJhc2VLZXk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlkZW50aXR5S2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuaWRlbnRpdHlLZXkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LmlkZW50aXR5S2V5LCBtZXNzYWdlLmlkZW50aXR5S2V5ID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LmlkZW50aXR5S2V5KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5pZGVudGl0eUtleS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSBvYmplY3QuaWRlbnRpdHlLZXk7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1lc3NhZ2UgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5tZXNzYWdlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5tZXNzYWdlLCBtZXNzYWdlLm1lc3NhZ2UgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QubWVzc2FnZSkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3QubWVzc2FnZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IG9iamVjdC5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFByZUtleVdoaXNwZXJNZXNzYWdlIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHt0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlfSBtZXNzYWdlIFByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgUHJlS2V5V2hpc3Blck1lc3NhZ2UudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QucHJlS2V5SWQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5iYXNlS2V5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmJhc2VLZXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmJhc2VLZXkgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LmJhc2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaWRlbnRpdHlLZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaWRlbnRpdHlLZXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlkZW50aXR5S2V5ID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5pZGVudGl0eUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm1lc3NhZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm1lc3NhZ2UgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QucmVnaXN0cmF0aW9uSWQgPSAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5zaWduZWRQcmVLZXlJZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVLZXlJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVLZXlJZFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucHJlS2V5SWQgPSBtZXNzYWdlLnByZUtleUlkO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmFzZUtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXNlS2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5iYXNlS2V5ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmJhc2VLZXksIDAsIG1lc3NhZ2UuYmFzZUtleS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmJhc2VLZXkpIDogbWVzc2FnZS5iYXNlS2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaWRlbnRpdHlLZXlcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmlkZW50aXR5S2V5ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmlkZW50aXR5S2V5LCAwLCBtZXNzYWdlLmlkZW50aXR5S2V5Lmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UuaWRlbnRpdHlLZXkpIDogbWVzc2FnZS5pZGVudGl0eUtleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubWVzc2FnZSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5tZXNzYWdlLCAwLCBtZXNzYWdlLm1lc3NhZ2UubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5tZXNzYWdlKSA6IG1lc3NhZ2UubWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlZ2lzdHJhdGlvbklkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJlZ2lzdHJhdGlvbklkXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5yZWdpc3RyYXRpb25JZCA9IG1lc3NhZ2UucmVnaXN0cmF0aW9uSWQ7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zaWduZWRQcmVLZXlJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzaWduZWRQcmVLZXlJZFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3Quc2lnbmVkUHJlS2V5SWQgPSBtZXNzYWdlLnNpZ25lZFByZUtleUlkO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBQcmVLZXlXaGlzcGVyTWVzc2FnZSB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLlByZUtleVdoaXNwZXJNZXNzYWdlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBQcmVLZXlXaGlzcGVyTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFByZUtleVdoaXNwZXJNZXNzYWdlO1xuICAgIH0pKCk7XG5cbiAgICB0ZXh0c2VjdXJlLktleUV4Y2hhbmdlTWVzc2FnZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEtleUV4Y2hhbmdlTWVzc2FnZS5cbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmVcbiAgICAgICAgICogQGludGVyZmFjZSBJS2V5RXhjaGFuZ2VNZXNzYWdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtpZF0gS2V5RXhjaGFuZ2VNZXNzYWdlIGlkXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbYmFzZUtleV0gS2V5RXhjaGFuZ2VNZXNzYWdlIGJhc2VLZXlcbiAgICAgICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtlcGhlbWVyYWxLZXldIEtleUV4Y2hhbmdlTWVzc2FnZSBlcGhlbWVyYWxLZXlcbiAgICAgICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtpZGVudGl0eUtleV0gS2V5RXhjaGFuZ2VNZXNzYWdlIGlkZW50aXR5S2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbYmFzZUtleVNpZ25hdHVyZV0gS2V5RXhjaGFuZ2VNZXNzYWdlIGJhc2VLZXlTaWduYXR1cmVcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgS2V5RXhjaGFuZ2VNZXNzYWdlLlxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZVxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBLZXlFeGNoYW5nZU1lc3NhZ2UuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElLZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7dGV4dHNlY3VyZS5JS2V5RXhjaGFuZ2VNZXNzYWdlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBLZXlFeGNoYW5nZU1lc3NhZ2UocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZXlFeGNoYW5nZU1lc3NhZ2UgaWQuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gaWRcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuS2V5RXhjaGFuZ2VNZXNzYWdlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgS2V5RXhjaGFuZ2VNZXNzYWdlLnByb3RvdHlwZS5pZCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtleUV4Y2hhbmdlTWVzc2FnZSBiYXNlS2V5LlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBiYXNlS2V5XG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLktleUV4Y2hhbmdlTWVzc2FnZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEtleUV4Y2hhbmdlTWVzc2FnZS5wcm90b3R5cGUuYmFzZUtleSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtleUV4Y2hhbmdlTWVzc2FnZSBlcGhlbWVyYWxLZXkuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IGVwaGVtZXJhbEtleVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBLZXlFeGNoYW5nZU1lc3NhZ2UucHJvdG90eXBlLmVwaGVtZXJhbEtleSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtleUV4Y2hhbmdlTWVzc2FnZSBpZGVudGl0eUtleS5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0gaWRlbnRpdHlLZXlcbiAgICAgICAgICogQG1lbWJlcm9mIHRleHRzZWN1cmUuS2V5RXhjaGFuZ2VNZXNzYWdlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgS2V5RXhjaGFuZ2VNZXNzYWdlLnByb3RvdHlwZS5pZGVudGl0eUtleSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtleUV4Y2hhbmdlTWVzc2FnZSBiYXNlS2V5U2lnbmF0dXJlLlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBiYXNlS2V5U2lnbmF0dXJlXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLktleUV4Y2hhbmdlTWVzc2FnZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEtleUV4Y2hhbmdlTWVzc2FnZS5wcm90b3R5cGUuYmFzZUtleVNpZ25hdHVyZSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgS2V5RXhjaGFuZ2VNZXNzYWdlIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3RleHRzZWN1cmUuSUtleUV4Y2hhbmdlTWVzc2FnZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7dGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2V9IEtleUV4Y2hhbmdlTWVzc2FnZSBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgS2V5RXhjaGFuZ2VNZXNzYWdlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleUV4Y2hhbmdlTWVzc2FnZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEtleUV4Y2hhbmdlTWVzc2FnZSBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayB0ZXh0c2VjdXJlLktleUV4Y2hhbmdlTWVzc2FnZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3RleHRzZWN1cmUuSUtleUV4Y2hhbmdlTWVzc2FnZX0gbWVzc2FnZSBLZXlFeGNoYW5nZU1lc3NhZ2UgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBLZXlFeGNoYW5nZU1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlkXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS51aW50MzIobWVzc2FnZS5pZCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5iYXNlS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJhc2VLZXlcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5ieXRlcyhtZXNzYWdlLmJhc2VLZXkpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXBoZW1lcmFsS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVwaGVtZXJhbEtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLmJ5dGVzKG1lc3NhZ2UuZXBoZW1lcmFsS2V5KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlkZW50aXR5S2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlkZW50aXR5S2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuYnl0ZXMobWVzc2FnZS5pZGVudGl0eUtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5iYXNlS2V5U2lnbmF0dXJlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJhc2VLZXlTaWduYXR1cmVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5ieXRlcyhtZXNzYWdlLmJhc2VLZXlTaWduYXR1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEtleUV4Y2hhbmdlTWVzc2FnZSBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayB0ZXh0c2VjdXJlLktleUV4Y2hhbmdlTWVzc2FnZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3RleHRzZWN1cmUuSUtleUV4Y2hhbmdlTWVzc2FnZX0gbWVzc2FnZSBLZXlFeGNoYW5nZU1lc3NhZ2UgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBLZXlFeGNoYW5nZU1lc3NhZ2UuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBLZXlFeGNoYW5nZU1lc3NhZ2UgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge3RleHRzZWN1cmUuS2V5RXhjaGFuZ2VNZXNzYWdlfSBLZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBLZXlFeGNoYW5nZU1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QudGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJhc2VLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVwaGVtZXJhbEtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJhc2VLZXlTaWduYXR1cmUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEtleUV4Y2hhbmdlTWVzc2FnZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLktleUV4Y2hhbmdlTWVzc2FnZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7dGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2V9IEtleUV4Y2hhbmdlTWVzc2FnZVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEtleUV4Y2hhbmdlTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBLZXlFeGNoYW5nZU1lc3NhZ2UgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEtleUV4Y2hhbmdlTWVzc2FnZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlkKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaWQ6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmJhc2VLZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmFzZUtleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmJhc2VLZXkgJiYgdHlwZW9mIG1lc3NhZ2UuYmFzZUtleS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5iYXNlS2V5KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJhc2VLZXk6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXBoZW1lcmFsS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVwaGVtZXJhbEtleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmVwaGVtZXJhbEtleSAmJiB0eXBlb2YgbWVzc2FnZS5lcGhlbWVyYWxLZXkubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZXBoZW1lcmFsS2V5KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVwaGVtZXJhbEtleTogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eUtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZGVudGl0eUtleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmlkZW50aXR5S2V5ICYmIHR5cGVvZiBtZXNzYWdlLmlkZW50aXR5S2V5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmlkZW50aXR5S2V5KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlkZW50aXR5S2V5OiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmJhc2VLZXlTaWduYXR1cmUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmFzZUtleVNpZ25hdHVyZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmJhc2VLZXlTaWduYXR1cmUgJiYgdHlwZW9mIG1lc3NhZ2UuYmFzZUtleVNpZ25hdHVyZS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5iYXNlS2V5U2lnbmF0dXJlKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJhc2VLZXlTaWduYXR1cmU6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBLZXlFeGNoYW5nZU1lc3NhZ2UgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHt0ZXh0c2VjdXJlLktleUV4Y2hhbmdlTWVzc2FnZX0gS2V5RXhjaGFuZ2VNZXNzYWdlXG4gICAgICAgICAqL1xuICAgICAgICBLZXlFeGNoYW5nZU1lc3NhZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QudGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LnRleHRzZWN1cmUuS2V5RXhjaGFuZ2VNZXNzYWdlKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IG9iamVjdC5pZCA+Pj4gMDtcbiAgICAgICAgICAgIGlmIChvYmplY3QuYmFzZUtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmJhc2VLZXkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LmJhc2VLZXksIG1lc3NhZ2UuYmFzZUtleSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5iYXNlS2V5KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5iYXNlS2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iYXNlS2V5ID0gb2JqZWN0LmJhc2VLZXk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmVwaGVtZXJhbEtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmVwaGVtZXJhbEtleSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3QuZXBoZW1lcmFsS2V5LCBtZXNzYWdlLmVwaGVtZXJhbEtleSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5lcGhlbWVyYWxLZXkpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LmVwaGVtZXJhbEtleS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXBoZW1lcmFsS2V5ID0gb2JqZWN0LmVwaGVtZXJhbEtleTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaWRlbnRpdHlLZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5pZGVudGl0eUtleSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3QuaWRlbnRpdHlLZXksIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QuaWRlbnRpdHlLZXkpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LmlkZW50aXR5S2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSA9IG9iamVjdC5pZGVudGl0eUtleTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuYmFzZUtleVNpZ25hdHVyZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmJhc2VLZXlTaWduYXR1cmUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LmJhc2VLZXlTaWduYXR1cmUsIG1lc3NhZ2UuYmFzZUtleVNpZ25hdHVyZSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5iYXNlS2V5U2lnbmF0dXJlKSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5iYXNlS2V5U2lnbmF0dXJlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iYXNlS2V5U2lnbmF0dXJlID0gb2JqZWN0LmJhc2VLZXlTaWduYXR1cmU7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgS2V5RXhjaGFuZ2VNZXNzYWdlIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiB0ZXh0c2VjdXJlLktleUV4Y2hhbmdlTWVzc2FnZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7dGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2V9IG1lc3NhZ2UgS2V5RXhjaGFuZ2VNZXNzYWdlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgS2V5RXhjaGFuZ2VNZXNzYWdlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmlkID0gMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYmFzZUtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5iYXNlS2V5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iYXNlS2V5ID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5iYXNlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVwaGVtZXJhbEtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5lcGhlbWVyYWxLZXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVwaGVtZXJhbEtleSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3QuZXBoZW1lcmFsS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlkZW50aXR5S2V5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlkZW50aXR5S2V5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pZGVudGl0eUtleSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3QuaWRlbnRpdHlLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYmFzZUtleVNpZ25hdHVyZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5iYXNlS2V5U2lnbmF0dXJlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iYXNlS2V5U2lnbmF0dXJlID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5iYXNlS2V5U2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuaWQgPSBtZXNzYWdlLmlkO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmFzZUtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXNlS2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5iYXNlS2V5ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmJhc2VLZXksIDAsIG1lc3NhZ2UuYmFzZUtleS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmJhc2VLZXkpIDogbWVzc2FnZS5iYXNlS2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXBoZW1lcmFsS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVwaGVtZXJhbEtleVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZXBoZW1lcmFsS2V5ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmVwaGVtZXJhbEtleSwgMCwgbWVzc2FnZS5lcGhlbWVyYWxLZXkubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5lcGhlbWVyYWxLZXkpIDogbWVzc2FnZS5lcGhlbWVyYWxLZXk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eUtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZGVudGl0eUtleVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuaWRlbnRpdHlLZXkgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UuaWRlbnRpdHlLZXksIDAsIG1lc3NhZ2UuaWRlbnRpdHlLZXkubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5pZGVudGl0eUtleSkgOiBtZXNzYWdlLmlkZW50aXR5S2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmFzZUtleVNpZ25hdHVyZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXNlS2V5U2lnbmF0dXJlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5iYXNlS2V5U2lnbmF0dXJlID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmJhc2VLZXlTaWduYXR1cmUsIDAsIG1lc3NhZ2UuYmFzZUtleVNpZ25hdHVyZS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmJhc2VLZXlTaWduYXR1cmUpIDogbWVzc2FnZS5iYXNlS2V5U2lnbmF0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBLZXlFeGNoYW5nZU1lc3NhZ2UgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgdGV4dHNlY3VyZS5LZXlFeGNoYW5nZU1lc3NhZ2VcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEtleUV4Y2hhbmdlTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEtleUV4Y2hhbmdlTWVzc2FnZTtcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIHRleHRzZWN1cmU7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRyb290O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/WhisperTextProtocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/base_key_type.js":
/*!*****************************************************!*\
  !*** ./node_modules/libsignal/src/base_key_type.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nconst BaseKeyType = {\n  OURS: 1,\n  THEIRS: 2\n};\n\nmodule.exports = BaseKeyType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9iYXNlX2tleV90eXBlLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9iYXNlX2tleV90eXBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgQmFzZUtleVR5cGUgPSB7XG4gIE9VUlM6IDEsXG4gIFRIRUlSUzogMlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlS2V5VHlwZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/base_key_type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/chain_type.js":
/*!**************************************************!*\
  !*** ./node_modules/libsignal/src/chain_type.js ***!
  \**************************************************/
/***/ ((module) => {

eval("const ChainType = {\n    SENDING: 1,\n    RECEIVING: 2\n};\n\nmodule.exports = ChainType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9jaGFpbl90eXBlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvc3JjL2NoYWluX3R5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ2hhaW5UeXBlID0ge1xuICAgIFNFTkRJTkc6IDEsXG4gICAgUkVDRUlWSU5HOiAyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYWluVHlwZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/chain_type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/crypto.js":
/*!**********************************************!*\
  !*** ./node_modules/libsignal/src/crypto.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// vim: ts=4:sw=4\n\n\n\nconst nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\n\nfunction assertBuffer(value) {\n    if (!(value instanceof Buffer)) {\n        throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);\n    }\n    return value;\n}\n\n\nfunction encrypt(key, data, iv) {\n    assertBuffer(key);\n    assertBuffer(data);\n    assertBuffer(iv);\n    const cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n    return Buffer.concat([cipher.update(data), cipher.final()]);\n}\n\n\nfunction decrypt(key, data, iv) {\n    assertBuffer(key);\n    assertBuffer(data);\n    assertBuffer(iv);\n    const decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n    return Buffer.concat([decipher.update(data), decipher.final()]);\n}\n\n\nfunction calculateMAC(key, data) {\n    assertBuffer(key);\n    assertBuffer(data);\n    const hmac = nodeCrypto.createHmac('sha256', key);\n    hmac.update(data);\n    return Buffer.from(hmac.digest());\n}\n\n\nfunction hash(data) {\n    assertBuffer(data);\n    const sha512 = nodeCrypto.createHash('sha512');\n    sha512.update(data);\n    return sha512.digest();\n}\n\n\n// Salts always end up being 32 bytes\nfunction deriveSecrets(input, salt, info, chunks) {\n    // Specific implementation of RFC 5869 that only returns the first 3 32-byte chunks\n    assertBuffer(input);\n    assertBuffer(salt);\n    assertBuffer(info);\n    if (salt.byteLength != 32) {\n        throw new Error(\"Got salt of incorrect length\");\n    }\n    chunks = chunks || 3;\n    assert(chunks >= 1 && chunks <= 3);\n    const PRK = calculateMAC(salt, input);\n    const infoArray = new Uint8Array(info.byteLength + 1 + 32);\n    infoArray.set(info, 32);\n    infoArray[infoArray.length - 1] = 1;\n    const signed = [calculateMAC(PRK, Buffer.from(infoArray.slice(32)))];\n    if (chunks > 1) {\n        infoArray.set(signed[signed.length - 1]);\n        infoArray[infoArray.length - 1] = 2;\n        signed.push(calculateMAC(PRK, Buffer.from(infoArray)));\n    }\n    if (chunks > 2) {\n        infoArray.set(signed[signed.length - 1]);\n        infoArray[infoArray.length - 1] = 3;\n        signed.push(calculateMAC(PRK, Buffer.from(infoArray)));\n    }\n    return signed;\n}\n\nfunction verifyMAC(data, key, mac, length) {\n    const calculatedMac = calculateMAC(key, data).slice(0, length);\n    if (mac.length !== length || calculatedMac.length !== length) {\n        throw new Error(\"Bad MAC length\");\n    }\n    if (!mac.equals(calculatedMac)) {\n        throw new Error(\"Bad MAC\");\n    }\n}\n\nmodule.exports = {\n    deriveSecrets,\n    decrypt,\n    encrypt,\n    hash,\n    calculateMAC,\n    verifyMAC\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9jcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHNCQUFROzs7QUFHL0I7QUFDQTtBQUNBLHVEQUF1RCx1QkFBdUI7QUFDOUU7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvc3JjL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aW06IHRzPTQ6c3c9NFxuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5vZGVDcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5cbmZ1bmN0aW9uIGFzc2VydEJ1ZmZlcih2YWx1ZSkge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYEV4cGVjdGVkIEJ1ZmZlciBpbnN0ZWFkIG9mOiAke3ZhbHVlLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuXG5mdW5jdGlvbiBlbmNyeXB0KGtleSwgZGF0YSwgaXYpIHtcbiAgICBhc3NlcnRCdWZmZXIoa2V5KTtcbiAgICBhc3NlcnRCdWZmZXIoZGF0YSk7XG4gICAgYXNzZXJ0QnVmZmVyKGl2KTtcbiAgICBjb25zdCBjaXBoZXIgPSBub2RlQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KCdhZXMtMjU2LWNiYycsIGtleSwgaXYpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtjaXBoZXIudXBkYXRlKGRhdGEpLCBjaXBoZXIuZmluYWwoKV0pO1xufVxuXG5cbmZ1bmN0aW9uIGRlY3J5cHQoa2V5LCBkYXRhLCBpdikge1xuICAgIGFzc2VydEJ1ZmZlcihrZXkpO1xuICAgIGFzc2VydEJ1ZmZlcihkYXRhKTtcbiAgICBhc3NlcnRCdWZmZXIoaXYpO1xuICAgIGNvbnN0IGRlY2lwaGVyID0gbm9kZUNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMjU2LWNiYycsIGtleSwgaXYpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtkZWNpcGhlci51cGRhdGUoZGF0YSksIGRlY2lwaGVyLmZpbmFsKCldKTtcbn1cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVNQUMoa2V5LCBkYXRhKSB7XG4gICAgYXNzZXJ0QnVmZmVyKGtleSk7XG4gICAgYXNzZXJ0QnVmZmVyKGRhdGEpO1xuICAgIGNvbnN0IGhtYWMgPSBub2RlQ3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIGtleSk7XG4gICAgaG1hYy51cGRhdGUoZGF0YSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhtYWMuZGlnZXN0KCkpO1xufVxuXG5cbmZ1bmN0aW9uIGhhc2goZGF0YSkge1xuICAgIGFzc2VydEJ1ZmZlcihkYXRhKTtcbiAgICBjb25zdCBzaGE1MTIgPSBub2RlQ3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTUxMicpO1xuICAgIHNoYTUxMi51cGRhdGUoZGF0YSk7XG4gICAgcmV0dXJuIHNoYTUxMi5kaWdlc3QoKTtcbn1cblxuXG4vLyBTYWx0cyBhbHdheXMgZW5kIHVwIGJlaW5nIDMyIGJ5dGVzXG5mdW5jdGlvbiBkZXJpdmVTZWNyZXRzKGlucHV0LCBzYWx0LCBpbmZvLCBjaHVua3MpIHtcbiAgICAvLyBTcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiBSRkMgNTg2OSB0aGF0IG9ubHkgcmV0dXJucyB0aGUgZmlyc3QgMyAzMi1ieXRlIGNodW5rc1xuICAgIGFzc2VydEJ1ZmZlcihpbnB1dCk7XG4gICAgYXNzZXJ0QnVmZmVyKHNhbHQpO1xuICAgIGFzc2VydEJ1ZmZlcihpbmZvKTtcbiAgICBpZiAoc2FsdC5ieXRlTGVuZ3RoICE9IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCBzYWx0IG9mIGluY29ycmVjdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGNodW5rcyA9IGNodW5rcyB8fCAzO1xuICAgIGFzc2VydChjaHVua3MgPj0gMSAmJiBjaHVua3MgPD0gMyk7XG4gICAgY29uc3QgUFJLID0gY2FsY3VsYXRlTUFDKHNhbHQsIGlucHV0KTtcbiAgICBjb25zdCBpbmZvQXJyYXkgPSBuZXcgVWludDhBcnJheShpbmZvLmJ5dGVMZW5ndGggKyAxICsgMzIpO1xuICAgIGluZm9BcnJheS5zZXQoaW5mbywgMzIpO1xuICAgIGluZm9BcnJheVtpbmZvQXJyYXkubGVuZ3RoIC0gMV0gPSAxO1xuICAgIGNvbnN0IHNpZ25lZCA9IFtjYWxjdWxhdGVNQUMoUFJLLCBCdWZmZXIuZnJvbShpbmZvQXJyYXkuc2xpY2UoMzIpKSldO1xuICAgIGlmIChjaHVua3MgPiAxKSB7XG4gICAgICAgIGluZm9BcnJheS5zZXQoc2lnbmVkW3NpZ25lZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGluZm9BcnJheVtpbmZvQXJyYXkubGVuZ3RoIC0gMV0gPSAyO1xuICAgICAgICBzaWduZWQucHVzaChjYWxjdWxhdGVNQUMoUFJLLCBCdWZmZXIuZnJvbShpbmZvQXJyYXkpKSk7XG4gICAgfVxuICAgIGlmIChjaHVua3MgPiAyKSB7XG4gICAgICAgIGluZm9BcnJheS5zZXQoc2lnbmVkW3NpZ25lZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGluZm9BcnJheVtpbmZvQXJyYXkubGVuZ3RoIC0gMV0gPSAzO1xuICAgICAgICBzaWduZWQucHVzaChjYWxjdWxhdGVNQUMoUFJLLCBCdWZmZXIuZnJvbShpbmZvQXJyYXkpKSk7XG4gICAgfVxuICAgIHJldHVybiBzaWduZWQ7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeU1BQyhkYXRhLCBrZXksIG1hYywgbGVuZ3RoKSB7XG4gICAgY29uc3QgY2FsY3VsYXRlZE1hYyA9IGNhbGN1bGF0ZU1BQyhrZXksIGRhdGEpLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgaWYgKG1hYy5sZW5ndGggIT09IGxlbmd0aCB8fCBjYWxjdWxhdGVkTWFjLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBNQUMgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBpZiAoIW1hYy5lcXVhbHMoY2FsY3VsYXRlZE1hYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIE1BQ1wiKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlcml2ZVNlY3JldHMsXG4gICAgZGVjcnlwdCxcbiAgICBlbmNyeXB0LFxuICAgIGhhc2gsXG4gICAgY2FsY3VsYXRlTUFDLFxuICAgIHZlcmlmeU1BQ1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/curve.js":
/*!*********************************************!*\
  !*** ./node_modules/libsignal/src/curve.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n\nconst curveJs = __webpack_require__(/*! curve25519-js */ \"(rsc)/./node_modules/curve25519-js/lib/index.js\");\nconst nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\n// from: https://github.com/digitalbazaar/x25519-key-agreement-key-2019/blob/master/lib/crypto.js\nconst PUBLIC_KEY_DER_PREFIX = Buffer.from([\n    48, 42, 48, 5, 6, 3, 43, 101, 110, 3, 33, 0\n]);\n  \nconst PRIVATE_KEY_DER_PREFIX = Buffer.from([\n    48, 46, 2, 1, 0, 48, 5, 6, 3, 43, 101, 110, 4, 34, 4, 32\n]);\n\nconst KEY_BUNDLE_TYPE = Buffer.from([5]);\n\nconst prefixKeyInPublicKey = function (pubKey) {\n  return Buffer.concat([KEY_BUNDLE_TYPE, pubKey]);\n};\n\nfunction validatePrivKey(privKey) {\n    if (privKey === undefined) {\n        throw new Error(\"Undefined private key\");\n    }\n    if (!(privKey instanceof Buffer)) {\n        throw new Error(`Invalid private key type: ${privKey.constructor.name}`);\n    }\n    if (privKey.byteLength != 32) {\n        throw new Error(`Incorrect private key length: ${privKey.byteLength}`);\n    }\n}\n\nfunction scrubPubKeyFormat(pubKey) {\n    if (!(pubKey instanceof Buffer)) {\n        throw new Error(`Invalid public key type: ${pubKey.constructor.name}`);\n    }\n    if (pubKey === undefined || ((pubKey.byteLength != 33 || pubKey[0] != 5) && pubKey.byteLength != 32)) {\n        throw new Error(\"Invalid public key\");\n    }\n    if (pubKey.byteLength == 33) {\n        return pubKey.slice(1);\n    } else {\n        console.error(\"WARNING: Expected pubkey of length 33, please report the ST and client that generated the pubkey\");\n        return pubKey;\n    }\n}\n\nfunction unclampEd25519PrivateKey(clampedSk) {\n    const unclampedSk = new Uint8Array(clampedSk);\n\n    // Fix the first byte\n    unclampedSk[0] |= 6; // Ensure last 3 bits match expected `110` pattern\n\n    // Fix the last byte\n    unclampedSk[31] |= 128; // Restore the highest bit\n    unclampedSk[31] &= ~64; // Clear the second-highest bit\n\n    return unclampedSk;\n}\n\nexports.getPublicFromPrivateKey = function(privKey) {\n    const unclampedPK = unclampEd25519PrivateKey(privKey);\n    const keyPair = curveJs.generateKeyPair(unclampedPK);\n    return prefixKeyInPublicKey(Buffer.from(keyPair.public));\n};\n\nexports.generateKeyPair = function() {\n    try {\n        const {publicKey: publicDerBytes, privateKey: privateDerBytes} = nodeCrypto.generateKeyPairSync(\n            'x25519',\n            {\n                publicKeyEncoding: { format: 'der', type: 'spki' },\n                privateKeyEncoding: { format: 'der', type: 'pkcs8' }\n            }\n        );\n        const pubKey = publicDerBytes.slice(PUBLIC_KEY_DER_PREFIX.length, PUBLIC_KEY_DER_PREFIX.length + 32);\n    \n        const privKey = privateDerBytes.slice(PRIVATE_KEY_DER_PREFIX.length, PRIVATE_KEY_DER_PREFIX.length + 32);\n    \n        return {\n            pubKey: prefixKeyInPublicKey(pubKey),\n            privKey\n        };\n    } catch(e) {\n        const keyPair = curveJs.generateKeyPair(nodeCrypto.randomBytes(32));\n        return {\n            privKey: Buffer.from(keyPair.private),\n            pubKey: prefixKeyInPublicKey(Buffer.from(keyPair.public)),\n        };\n    }\n};\n\nexports.calculateAgreement = function(pubKey, privKey) {\n    pubKey = scrubPubKeyFormat(pubKey);\n    validatePrivKey(privKey);\n    if (!pubKey || pubKey.byteLength != 32) {\n        throw new Error(\"Invalid public key\");\n    }\n\n    if(typeof nodeCrypto.diffieHellman === 'function') {\n        const nodePrivateKey = nodeCrypto.createPrivateKey({\n            key: Buffer.concat([PRIVATE_KEY_DER_PREFIX, privKey]),\n            format: 'der',\n            type: 'pkcs8'\n        });\n        const nodePublicKey = nodeCrypto.createPublicKey({\n            key: Buffer.concat([PUBLIC_KEY_DER_PREFIX, pubKey]),\n            format: 'der',\n            type: 'spki'\n        });\n        \n        return nodeCrypto.diffieHellman({\n            privateKey: nodePrivateKey,\n            publicKey: nodePublicKey,\n        });\n    } else {\n        const secret = curveJs.sharedKey(privKey, pubKey);\n        return Buffer.from(secret);\n    }\n};\n\nexports.calculateSignature = function(privKey, message) {\n    validatePrivKey(privKey);\n    if (!message) {\n        throw new Error(\"Invalid message\");\n    }\n    return Buffer.from(curveJs.sign(privKey, message));\n};\n\nexports.verifySignature = function(pubKey, msg, sig, isInit) {\n    pubKey = scrubPubKeyFormat(pubKey);\n    if (!pubKey || pubKey.byteLength != 32) {\n        throw new Error(\"Invalid public key\");\n    }\n    if (!msg) {\n        throw new Error(\"Invalid message\");\n    }\n    if (!sig || sig.byteLength != 64) {\n        throw new Error(\"Invalid signature\");\n    }\n    return isInit ? true : curveJs.verify(pubKey, msg, sig);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWU7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsc0JBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx5QkFBeUI7QUFDOUU7QUFDQTtBQUNBLHlEQUF5RCxtQkFBbUI7QUFDNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELHdCQUF3QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQSxlQUFlLHdEQUF3RDtBQUN2RTtBQUNBO0FBQ0EscUNBQXFDLDZCQUE2QjtBQUNsRSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvc3JjL2N1cnZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjdXJ2ZUpzID0gcmVxdWlyZSgnY3VydmUyNTUxOS1qcycpO1xuY29uc3Qgbm9kZUNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuLy8gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2RpZ2l0YWxiYXphYXIveDI1NTE5LWtleS1hZ3JlZW1lbnQta2V5LTIwMTkvYmxvYi9tYXN0ZXIvbGliL2NyeXB0by5qc1xuY29uc3QgUFVCTElDX0tFWV9ERVJfUFJFRklYID0gQnVmZmVyLmZyb20oW1xuICAgIDQ4LCA0MiwgNDgsIDUsIDYsIDMsIDQzLCAxMDEsIDExMCwgMywgMzMsIDBcbl0pO1xuICBcbmNvbnN0IFBSSVZBVEVfS0VZX0RFUl9QUkVGSVggPSBCdWZmZXIuZnJvbShbXG4gICAgNDgsIDQ2LCAyLCAxLCAwLCA0OCwgNSwgNiwgMywgNDMsIDEwMSwgMTEwLCA0LCAzNCwgNCwgMzJcbl0pO1xuXG5jb25zdCBLRVlfQlVORExFX1RZUEUgPSBCdWZmZXIuZnJvbShbNV0pO1xuXG5jb25zdCBwcmVmaXhLZXlJblB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWJLZXkpIHtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW0tFWV9CVU5ETEVfVFlQRSwgcHViS2V5XSk7XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByaXZLZXkocHJpdktleSkge1xuICAgIGlmIChwcml2S2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5kZWZpbmVkIHByaXZhdGUga2V5XCIpO1xuICAgIH1cbiAgICBpZiAoIShwcml2S2V5IGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJpdmF0ZSBrZXkgdHlwZTogJHtwcml2S2V5LmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgfVxuICAgIGlmIChwcml2S2V5LmJ5dGVMZW5ndGggIT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgcHJpdmF0ZSBrZXkgbGVuZ3RoOiAke3ByaXZLZXkuYnl0ZUxlbmd0aH1gKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNjcnViUHViS2V5Rm9ybWF0KHB1YktleSkge1xuICAgIGlmICghKHB1YktleSBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyBrZXkgdHlwZTogJHtwdWJLZXkuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKHB1YktleSA9PT0gdW5kZWZpbmVkIHx8ICgocHViS2V5LmJ5dGVMZW5ndGggIT0gMzMgfHwgcHViS2V5WzBdICE9IDUpICYmIHB1YktleS5ieXRlTGVuZ3RoICE9IDMyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHB1YmxpYyBrZXlcIik7XG4gICAgfVxuICAgIGlmIChwdWJLZXkuYnl0ZUxlbmd0aCA9PSAzMykge1xuICAgICAgICByZXR1cm4gcHViS2V5LnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXQVJOSU5HOiBFeHBlY3RlZCBwdWJrZXkgb2YgbGVuZ3RoIDMzLCBwbGVhc2UgcmVwb3J0IHRoZSBTVCBhbmQgY2xpZW50IHRoYXQgZ2VuZXJhdGVkIHRoZSBwdWJrZXlcIik7XG4gICAgICAgIHJldHVybiBwdWJLZXk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bmNsYW1wRWQyNTUxOVByaXZhdGVLZXkoY2xhbXBlZFNrKSB7XG4gICAgY29uc3QgdW5jbGFtcGVkU2sgPSBuZXcgVWludDhBcnJheShjbGFtcGVkU2spO1xuXG4gICAgLy8gRml4IHRoZSBmaXJzdCBieXRlXG4gICAgdW5jbGFtcGVkU2tbMF0gfD0gNjsgLy8gRW5zdXJlIGxhc3QgMyBiaXRzIG1hdGNoIGV4cGVjdGVkIGAxMTBgIHBhdHRlcm5cblxuICAgIC8vIEZpeCB0aGUgbGFzdCBieXRlXG4gICAgdW5jbGFtcGVkU2tbMzFdIHw9IDEyODsgLy8gUmVzdG9yZSB0aGUgaGlnaGVzdCBiaXRcbiAgICB1bmNsYW1wZWRTa1szMV0gJj0gfjY0OyAvLyBDbGVhciB0aGUgc2Vjb25kLWhpZ2hlc3QgYml0XG5cbiAgICByZXR1cm4gdW5jbGFtcGVkU2s7XG59XG5cbmV4cG9ydHMuZ2V0UHVibGljRnJvbVByaXZhdGVLZXkgPSBmdW5jdGlvbihwcml2S2V5KSB7XG4gICAgY29uc3QgdW5jbGFtcGVkUEsgPSB1bmNsYW1wRWQyNTUxOVByaXZhdGVLZXkocHJpdktleSk7XG4gICAgY29uc3Qga2V5UGFpciA9IGN1cnZlSnMuZ2VuZXJhdGVLZXlQYWlyKHVuY2xhbXBlZFBLKTtcbiAgICByZXR1cm4gcHJlZml4S2V5SW5QdWJsaWNLZXkoQnVmZmVyLmZyb20oa2V5UGFpci5wdWJsaWMpKTtcbn07XG5cbmV4cG9ydHMuZ2VuZXJhdGVLZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge3B1YmxpY0tleTogcHVibGljRGVyQnl0ZXMsIHByaXZhdGVLZXk6IHByaXZhdGVEZXJCeXRlc30gPSBub2RlQ3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoXG4gICAgICAgICAgICAneDI1NTE5JyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzogeyBmb3JtYXQ6ICdkZXInLCB0eXBlOiAnc3BraScgfSxcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHsgZm9ybWF0OiAnZGVyJywgdHlwZTogJ3BrY3M4JyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHB1YktleSA9IHB1YmxpY0RlckJ5dGVzLnNsaWNlKFBVQkxJQ19LRVlfREVSX1BSRUZJWC5sZW5ndGgsIFBVQkxJQ19LRVlfREVSX1BSRUZJWC5sZW5ndGggKyAzMik7XG4gICAgXG4gICAgICAgIGNvbnN0IHByaXZLZXkgPSBwcml2YXRlRGVyQnl0ZXMuc2xpY2UoUFJJVkFURV9LRVlfREVSX1BSRUZJWC5sZW5ndGgsIFBSSVZBVEVfS0VZX0RFUl9QUkVGSVgubGVuZ3RoICsgMzIpO1xuICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHViS2V5OiBwcmVmaXhLZXlJblB1YmxpY0tleShwdWJLZXkpLFxuICAgICAgICAgICAgcHJpdktleVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gY3VydmVKcy5nZW5lcmF0ZUtleVBhaXIobm9kZUNyeXB0by5yYW5kb21CeXRlcygzMikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpdktleTogQnVmZmVyLmZyb20oa2V5UGFpci5wcml2YXRlKSxcbiAgICAgICAgICAgIHB1YktleTogcHJlZml4S2V5SW5QdWJsaWNLZXkoQnVmZmVyLmZyb20oa2V5UGFpci5wdWJsaWMpKSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnRzLmNhbGN1bGF0ZUFncmVlbWVudCA9IGZ1bmN0aW9uKHB1YktleSwgcHJpdktleSkge1xuICAgIHB1YktleSA9IHNjcnViUHViS2V5Rm9ybWF0KHB1YktleSk7XG4gICAgdmFsaWRhdGVQcml2S2V5KHByaXZLZXkpO1xuICAgIGlmICghcHViS2V5IHx8IHB1YktleS5ieXRlTGVuZ3RoICE9IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHVibGljIGtleVwiKTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2Ygbm9kZUNyeXB0by5kaWZmaWVIZWxsbWFuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG5vZGVQcml2YXRlS2V5ID0gbm9kZUNyeXB0by5jcmVhdGVQcml2YXRlS2V5KHtcbiAgICAgICAgICAgIGtleTogQnVmZmVyLmNvbmNhdChbUFJJVkFURV9LRVlfREVSX1BSRUZJWCwgcHJpdktleV0pLFxuICAgICAgICAgICAgZm9ybWF0OiAnZGVyJyxcbiAgICAgICAgICAgIHR5cGU6ICdwa2NzOCdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5vZGVQdWJsaWNLZXkgPSBub2RlQ3J5cHRvLmNyZWF0ZVB1YmxpY0tleSh7XG4gICAgICAgICAgICBrZXk6IEJ1ZmZlci5jb25jYXQoW1BVQkxJQ19LRVlfREVSX1BSRUZJWCwgcHViS2V5XSksXG4gICAgICAgICAgICBmb3JtYXQ6ICdkZXInLFxuICAgICAgICAgICAgdHlwZTogJ3Nwa2knXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5vZGVDcnlwdG8uZGlmZmllSGVsbG1hbih7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBub2RlUHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogbm9kZVB1YmxpY0tleSxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gY3VydmVKcy5zaGFyZWRLZXkocHJpdktleSwgcHViS2V5KTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3JldCk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5jYWxjdWxhdGVTaWduYXR1cmUgPSBmdW5jdGlvbihwcml2S2V5LCBtZXNzYWdlKSB7XG4gICAgdmFsaWRhdGVQcml2S2V5KHByaXZLZXkpO1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1lc3NhZ2VcIik7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShjdXJ2ZUpzLnNpZ24ocHJpdktleSwgbWVzc2FnZSkpO1xufTtcblxuZXhwb3J0cy52ZXJpZnlTaWduYXR1cmUgPSBmdW5jdGlvbihwdWJLZXksIG1zZywgc2lnLCBpc0luaXQpIHtcbiAgICBwdWJLZXkgPSBzY3J1YlB1YktleUZvcm1hdChwdWJLZXkpO1xuICAgIGlmICghcHViS2V5IHx8IHB1YktleS5ieXRlTGVuZ3RoICE9IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHVibGljIGtleVwiKTtcbiAgICB9XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlXCIpO1xuICAgIH1cbiAgICBpZiAoIXNpZyB8fCBzaWcuYnl0ZUxlbmd0aCAhPSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hdHVyZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzSW5pdCA/IHRydWUgOiBjdXJ2ZUpzLnZlcmlmeShwdWJLZXksIG1zZywgc2lnKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/curve.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/errors.js":
/*!**********************************************!*\
  !*** ./node_modules/libsignal/src/errors.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// vim: ts=4:sw=4:expandtab\n\nexports.SignalError = class SignalError extends Error {};\n\nexports.UntrustedIdentityKeyError = class UntrustedIdentityKeyError extends exports.SignalError {\n    constructor(addr, identityKey) {\n        super();\n        this.name = 'UntrustedIdentityKeyError';\n        this.addr = addr;\n        this.identityKey = identityKey;\n    }\n};\n\nexports.SessionError = class SessionError extends exports.SignalError {\n    constructor(message) {\n        super(message);\n        this.name = 'SessionError';\n    }\n};\n\nexports.MessageCounterError = class MessageCounterError extends exports.SessionError {\n    constructor(message) {\n        super(message);\n        this.name = 'MessageCounterError';\n    }\n};\n\nexports.PreKeyError = class PreKeyError extends exports.SessionError {\n    constructor(message) {\n        super(message);\n        this.name = 'PreKeyError';\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsbUJBQW1COztBQUVuQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2xpYnNpZ25hbC9zcmMvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpbTogdHM9NDpzdz00OmV4cGFuZHRhYlxuXG5leHBvcnRzLlNpZ25hbEVycm9yID0gY2xhc3MgU2lnbmFsRXJyb3IgZXh0ZW5kcyBFcnJvciB7fTtcblxuZXhwb3J0cy5VbnRydXN0ZWRJZGVudGl0eUtleUVycm9yID0gY2xhc3MgVW50cnVzdGVkSWRlbnRpdHlLZXlFcnJvciBleHRlbmRzIGV4cG9ydHMuU2lnbmFsRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFkZHIsIGlkZW50aXR5S2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdVbnRydXN0ZWRJZGVudGl0eUtleUVycm9yJztcbiAgICAgICAgdGhpcy5hZGRyID0gYWRkcjtcbiAgICAgICAgdGhpcy5pZGVudGl0eUtleSA9IGlkZW50aXR5S2V5O1xuICAgIH1cbn07XG5cbmV4cG9ydHMuU2Vzc2lvbkVycm9yID0gY2xhc3MgU2Vzc2lvbkVycm9yIGV4dGVuZHMgZXhwb3J0cy5TaWduYWxFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Nlc3Npb25FcnJvcic7XG4gICAgfVxufTtcblxuZXhwb3J0cy5NZXNzYWdlQ291bnRlckVycm9yID0gY2xhc3MgTWVzc2FnZUNvdW50ZXJFcnJvciBleHRlbmRzIGV4cG9ydHMuU2Vzc2lvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTWVzc2FnZUNvdW50ZXJFcnJvcic7XG4gICAgfVxufTtcblxuZXhwb3J0cy5QcmVLZXlFcnJvciA9IGNsYXNzIFByZUtleUVycm9yIGV4dGVuZHMgZXhwb3J0cy5TZXNzaW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdQcmVLZXlFcnJvcic7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/keyhelper.js":
/*!*************************************************!*\
  !*** ./node_modules/libsignal/src/keyhelper.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// vim: ts=4:sw=4:expandtab\n\nconst curve = __webpack_require__(/*! ./curve */ \"(rsc)/./node_modules/libsignal/src/curve.js\");\nconst nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nfunction isNonNegativeInteger(n) {\n    return (typeof n === 'number' && (n % 1) === 0  && n >= 0);\n}\n\nexports.generateIdentityKeyPair = curve.generateKeyPair;\n\nexports.generateRegistrationId = function() {\n    var registrationId = Uint16Array.from(nodeCrypto.randomBytes(2))[0];\n    return registrationId & 0x3fff;\n};\n\nexports.generateSignedPreKey = function(identityKeyPair, signedKeyId) {\n    if (!(identityKeyPair.privKey instanceof Buffer) ||\n        identityKeyPair.privKey.byteLength != 32 ||\n        !(identityKeyPair.pubKey instanceof Buffer) ||\n        identityKeyPair.pubKey.byteLength != 33) {\n        throw new TypeError('Invalid argument for identityKeyPair');\n    }\n    if (!isNonNegativeInteger(signedKeyId)) {\n        throw new TypeError('Invalid argument for signedKeyId: ' + signedKeyId);\n    }\n    const keyPair = curve.generateKeyPair();\n    const sig = curve.calculateSignature(identityKeyPair.privKey, keyPair.pubKey);\n    return {\n        keyId: signedKeyId,\n        keyPair: keyPair,\n        signature: sig\n    };\n};\n\nexports.generatePreKey = function(keyId) {\n    if (!isNonNegativeInteger(keyId)) {\n        throw new TypeError('Invalid argument for keyId: ' + keyId);\n    }\n    const keyPair = curve.generateKeyPair();\n    return {\n        keyId,\n        keyPair\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9rZXloZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLDREQUFTO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLHNCQUFROztBQUVuQztBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2xpYnNpZ25hbC9zcmMva2V5aGVscGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpbTogdHM9NDpzdz00OmV4cGFuZHRhYlxuXG5jb25zdCBjdXJ2ZSA9IHJlcXVpcmUoJy4vY3VydmUnKTtcbmNvbnN0IG5vZGVDcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuZnVuY3Rpb24gaXNOb25OZWdhdGl2ZUludGVnZXIobikge1xuICAgIHJldHVybiAodHlwZW9mIG4gPT09ICdudW1iZXInICYmIChuICUgMSkgPT09IDAgICYmIG4gPj0gMCk7XG59XG5cbmV4cG9ydHMuZ2VuZXJhdGVJZGVudGl0eUtleVBhaXIgPSBjdXJ2ZS5nZW5lcmF0ZUtleVBhaXI7XG5cbmV4cG9ydHMuZ2VuZXJhdGVSZWdpc3RyYXRpb25JZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWdpc3RyYXRpb25JZCA9IFVpbnQxNkFycmF5LmZyb20obm9kZUNyeXB0by5yYW5kb21CeXRlcygyKSlbMF07XG4gICAgcmV0dXJuIHJlZ2lzdHJhdGlvbklkICYgMHgzZmZmO1xufTtcblxuZXhwb3J0cy5nZW5lcmF0ZVNpZ25lZFByZUtleSA9IGZ1bmN0aW9uKGlkZW50aXR5S2V5UGFpciwgc2lnbmVkS2V5SWQpIHtcbiAgICBpZiAoIShpZGVudGl0eUtleVBhaXIucHJpdktleSBpbnN0YW5jZW9mIEJ1ZmZlcikgfHxcbiAgICAgICAgaWRlbnRpdHlLZXlQYWlyLnByaXZLZXkuYnl0ZUxlbmd0aCAhPSAzMiB8fFxuICAgICAgICAhKGlkZW50aXR5S2V5UGFpci5wdWJLZXkgaW5zdGFuY2VvZiBCdWZmZXIpIHx8XG4gICAgICAgIGlkZW50aXR5S2V5UGFpci5wdWJLZXkuYnl0ZUxlbmd0aCAhPSAzMykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IGZvciBpZGVudGl0eUtleVBhaXInKTtcbiAgICB9XG4gICAgaWYgKCFpc05vbk5lZ2F0aXZlSW50ZWdlcihzaWduZWRLZXlJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCBmb3Igc2lnbmVkS2V5SWQ6ICcgKyBzaWduZWRLZXlJZCk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhaXIgPSBjdXJ2ZS5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgICBjb25zdCBzaWcgPSBjdXJ2ZS5jYWxjdWxhdGVTaWduYXR1cmUoaWRlbnRpdHlLZXlQYWlyLnByaXZLZXksIGtleVBhaXIucHViS2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlJZDogc2lnbmVkS2V5SWQsXG4gICAgICAgIGtleVBhaXI6IGtleVBhaXIsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnXG4gICAgfTtcbn07XG5cbmV4cG9ydHMuZ2VuZXJhdGVQcmVLZXkgPSBmdW5jdGlvbihrZXlJZCkge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIoa2V5SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgZm9yIGtleUlkOiAnICsga2V5SWQpO1xuICAgIH1cbiAgICBjb25zdCBrZXlQYWlyID0gY3VydmUuZ2VuZXJhdGVLZXlQYWlyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5SWQsXG4gICAgICAgIGtleVBhaXJcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/keyhelper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/protobufs.js":
/*!*************************************************!*\
  !*** ./node_modules/libsignal/src/protobufs.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n    textsecure: {\n        WhisperMessage,\n        PreKeyWhisperMessage\n    }\n} = __webpack_require__(/*! ./WhisperTextProtocol.js */ \"(rsc)/./node_modules/libsignal/src/WhisperTextProtocol.js\");\n\nmodule.exports = { WhisperMessage, PreKeyWhisperMessage };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9wcm90b2J1ZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJGQUEwQjs7QUFFdEMsbUJBQW1CIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvc3JjL3Byb3RvYnVmcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgICB0ZXh0c2VjdXJlOiB7XG4gICAgICAgIFdoaXNwZXJNZXNzYWdlLFxuICAgICAgICBQcmVLZXlXaGlzcGVyTWVzc2FnZVxuICAgIH1cbn0gPSByZXF1aXJlKCcuL1doaXNwZXJUZXh0UHJvdG9jb2wuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IFdoaXNwZXJNZXNzYWdlLCBQcmVLZXlXaGlzcGVyTWVzc2FnZSB9OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/protobufs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/protocol_address.js":
/*!********************************************************!*\
  !*** ./node_modules/libsignal/src/protocol_address.js ***!
  \********************************************************/
/***/ ((module) => {

eval("// vim: ts=4:sw=4:expandtab\n\n\nclass ProtocolAddress {\n\n    static from(encodedAddress) {\n        if (typeof encodedAddress !== 'string' || !encodedAddress.match(/.*\\.\\d+/)) {\n            throw new Error('Invalid address encoding');\n        }\n        const parts = encodedAddress.split('.');\n        return new this(parts[0], parseInt(parts[1]));\n    }\n\n    constructor(id, deviceId) {\n        if (typeof id !== 'string') {\n            throw new TypeError('id required for addr');\n        }\n        if (id.indexOf('.') !== -1) {\n            throw new TypeError('encoded addr detected');\n        }\n        this.id = id;\n        if (typeof deviceId !== 'number') {\n            throw new TypeError('number required for deviceId');\n        }\n        this.deviceId = deviceId;\n    }\n\n    toString() {\n        return `${this.id}.${this.deviceId}`;\n    }\n\n    is(other) {\n        if (!(other instanceof ProtocolAddress)) {\n            return false;\n        }\n        return other.id === this.id && other.deviceId === this.deviceId;\n    }\n}\n\nmodule.exports = ProtocolAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9wcm90b2NvbF9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRLEdBQUcsY0FBYztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9wcm90b2NvbF9hZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpbTogdHM9NDpzdz00OmV4cGFuZHRhYlxuXG5cbmNsYXNzIFByb3RvY29sQWRkcmVzcyB7XG5cbiAgICBzdGF0aWMgZnJvbShlbmNvZGVkQWRkcmVzcykge1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kZWRBZGRyZXNzICE9PSAnc3RyaW5nJyB8fCAhZW5jb2RlZEFkZHJlc3MubWF0Y2goLy4qXFwuXFxkKy8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyBlbmNvZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gZW5jb2RlZEFkZHJlc3Muc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHBhcnRzWzBdLCBwYXJzZUludChwYXJ0c1sxXSkpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGlkLCBkZXZpY2VJZCkge1xuICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWQgcmVxdWlyZWQgZm9yIGFkZHInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RlZCBhZGRyIGRldGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbnVtYmVyIHJlcXVpcmVkIGZvciBkZXZpY2VJZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9LiR7dGhpcy5kZXZpY2VJZH1gO1xuICAgIH1cblxuICAgIGlzKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUHJvdG9jb2xBZGRyZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdGhlci5pZCA9PT0gdGhpcy5pZCAmJiBvdGhlci5kZXZpY2VJZCA9PT0gdGhpcy5kZXZpY2VJZDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvdG9jb2xBZGRyZXNzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/protocol_address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/queue_job.js":
/*!*************************************************!*\
  !*** ./node_modules/libsignal/src/queue_job.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("// vim: ts=4:sw=4:expandtab\n \n /*\n  * jobQueue manages multiple queues indexed by device to serialize\n  * session io ops on the database.\n  */\n\n\n\nconst _queueAsyncBuckets = new Map();\nconst _gcLimit = 10000;\n\nasync function _asyncQueueExecutor(queue, cleanup) {\n    let offt = 0;\n    while (true) {\n        let limit = Math.min(queue.length, _gcLimit); // Break up thundering hurds for GC duty.\n        for (let i = offt; i < limit; i++) {\n            const job = queue[i];\n            try {\n                job.resolve(await job.awaitable());\n            } catch(e) {\n                job.reject(e);\n            }\n        }\n        if (limit < queue.length) {\n            /* Perform lazy GC of queue for faster iteration. */\n            if (limit >= _gcLimit) {\n                queue.splice(0, limit);\n                offt = 0;\n            } else {\n                offt = limit;\n            }\n        } else {\n            break;\n        }\n    }\n    cleanup();\n}\n\nmodule.exports = function(bucket, awaitable) {\n    /* Run the async awaitable only when all other async calls registered\n     * here have completed (or thrown).  The bucket argument is a hashable\n     * key representing the task queue to use. */\n    if (!awaitable.name) {\n        // Make debuging easier by adding a name to this function.\n        Object.defineProperty(awaitable, 'name', {writable: true});\n        if (typeof bucket === 'string') {\n            awaitable.name = bucket;\n        } else {\n            console.warn(\"Unhandled bucket type (for naming):\", typeof bucket, bucket);\n        }\n    }\n    let inactive;\n    if (!_queueAsyncBuckets.has(bucket)) {\n        _queueAsyncBuckets.set(bucket, []);\n        inactive = true;\n    }\n    const queue = _queueAsyncBuckets.get(bucket);\n    const job = new Promise((resolve, reject) => queue.push({\n        awaitable,\n        resolve,\n        reject\n    }));\n    if (inactive) {\n        /* An executor is not currently active; Start one now. */\n        _asyncQueueExecutor(queue, () => _queueAsyncBuckets.delete(bucket));\n    }\n    return job;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9xdWV1ZV9qb2IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7OztBQUdiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9saWJzaWduYWwvc3JjL3F1ZXVlX2pvYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aW06IHRzPTQ6c3c9NDpleHBhbmR0YWJcbiBcbiAvKlxuICAqIGpvYlF1ZXVlIG1hbmFnZXMgbXVsdGlwbGUgcXVldWVzIGluZGV4ZWQgYnkgZGV2aWNlIHRvIHNlcmlhbGl6ZVxuICAqIHNlc3Npb24gaW8gb3BzIG9uIHRoZSBkYXRhYmFzZS5cbiAgKi9cbid1c2Ugc3RyaWN0JztcblxuXG5jb25zdCBfcXVldWVBc3luY0J1Y2tldHMgPSBuZXcgTWFwKCk7XG5jb25zdCBfZ2NMaW1pdCA9IDEwMDAwO1xuXG5hc3luYyBmdW5jdGlvbiBfYXN5bmNRdWV1ZUV4ZWN1dG9yKHF1ZXVlLCBjbGVhbnVwKSB7XG4gICAgbGV0IG9mZnQgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBsaW1pdCA9IE1hdGgubWluKHF1ZXVlLmxlbmd0aCwgX2djTGltaXQpOyAvLyBCcmVhayB1cCB0aHVuZGVyaW5nIGh1cmRzIGZvciBHQyBkdXR5LlxuICAgICAgICBmb3IgKGxldCBpID0gb2ZmdDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBqb2IucmVzb2x2ZShhd2FpdCBqb2IuYXdhaXRhYmxlKCkpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgam9iLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPCBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIFBlcmZvcm0gbGF6eSBHQyBvZiBxdWV1ZSBmb3IgZmFzdGVyIGl0ZXJhdGlvbi4gKi9cbiAgICAgICAgICAgIGlmIChsaW1pdCA+PSBfZ2NMaW1pdCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgb2ZmdCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnQgPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihidWNrZXQsIGF3YWl0YWJsZSkge1xuICAgIC8qIFJ1biB0aGUgYXN5bmMgYXdhaXRhYmxlIG9ubHkgd2hlbiBhbGwgb3RoZXIgYXN5bmMgY2FsbHMgcmVnaXN0ZXJlZFxuICAgICAqIGhlcmUgaGF2ZSBjb21wbGV0ZWQgKG9yIHRocm93bikuICBUaGUgYnVja2V0IGFyZ3VtZW50IGlzIGEgaGFzaGFibGVcbiAgICAgKiBrZXkgcmVwcmVzZW50aW5nIHRoZSB0YXNrIHF1ZXVlIHRvIHVzZS4gKi9cbiAgICBpZiAoIWF3YWl0YWJsZS5uYW1lKSB7XG4gICAgICAgIC8vIE1ha2UgZGVidWdpbmcgZWFzaWVyIGJ5IGFkZGluZyBhIG5hbWUgdG8gdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGF3YWl0YWJsZSwgJ25hbWUnLCB7d3JpdGFibGU6IHRydWV9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhd2FpdGFibGUubmFtZSA9IGJ1Y2tldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuaGFuZGxlZCBidWNrZXQgdHlwZSAoZm9yIG5hbWluZyk6XCIsIHR5cGVvZiBidWNrZXQsIGJ1Y2tldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGluYWN0aXZlO1xuICAgIGlmICghX3F1ZXVlQXN5bmNCdWNrZXRzLmhhcyhidWNrZXQpKSB7XG4gICAgICAgIF9xdWV1ZUFzeW5jQnVja2V0cy5zZXQoYnVja2V0LCBbXSk7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgcXVldWUgPSBfcXVldWVBc3luY0J1Y2tldHMuZ2V0KGJ1Y2tldCk7XG4gICAgY29uc3Qgam9iID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gcXVldWUucHVzaCh7XG4gICAgICAgIGF3YWl0YWJsZSxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0XG4gICAgfSkpO1xuICAgIGlmIChpbmFjdGl2ZSkge1xuICAgICAgICAvKiBBbiBleGVjdXRvciBpcyBub3QgY3VycmVudGx5IGFjdGl2ZTsgU3RhcnQgb25lIG5vdy4gKi9cbiAgICAgICAgX2FzeW5jUXVldWVFeGVjdXRvcihxdWV1ZSwgKCkgPT4gX3F1ZXVlQXN5bmNCdWNrZXRzLmRlbGV0ZShidWNrZXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGpvYjtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/queue_job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/session_builder.js":
/*!*******************************************************!*\
  !*** ./node_modules/libsignal/src/session_builder.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nconst BaseKeyType = __webpack_require__(/*! ./base_key_type */ \"(rsc)/./node_modules/libsignal/src/base_key_type.js\");\nconst ChainType = __webpack_require__(/*! ./chain_type */ \"(rsc)/./node_modules/libsignal/src/chain_type.js\");\nconst SessionRecord = __webpack_require__(/*! ./session_record */ \"(rsc)/./node_modules/libsignal/src/session_record.js\");\nconst crypto = __webpack_require__(/*! ./crypto */ \"(rsc)/./node_modules/libsignal/src/crypto.js\");\nconst curve = __webpack_require__(/*! ./curve */ \"(rsc)/./node_modules/libsignal/src/curve.js\");\nconst errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/libsignal/src/errors.js\");\nconst queueJob = __webpack_require__(/*! ./queue_job */ \"(rsc)/./node_modules/libsignal/src/queue_job.js\");\n\n\nclass SessionBuilder {\n\n    constructor(storage, protocolAddress) {\n        this.addr = protocolAddress;\n        this.storage = storage;\n    }\n\n    async initOutgoing(device) {\n        const fqAddr = this.addr.toString();\n        return await queueJob(fqAddr, async () => {\n            if (!await this.storage.isTrustedIdentity(this.addr.id, device.identityKey)) {\n                throw new errors.UntrustedIdentityKeyError(this.addr.id, device.identityKey);\n            }\n            curve.verifySignature(device.identityKey, device.signedPreKey.publicKey,\n                                  device.signedPreKey.signature, true);\n            const baseKey = curve.generateKeyPair();\n            const devicePreKey = device.preKey && device.preKey.publicKey;\n            const session = await this.initSession(true, baseKey, undefined, device.identityKey,\n                                                   devicePreKey, device.signedPreKey.publicKey,\n                                                   device.registrationId);\n            session.pendingPreKey = {\n                signedKeyId: device.signedPreKey.keyId,\n                baseKey: baseKey.pubKey\n            };\n            if (device.preKey) {\n                session.pendingPreKey.preKeyId = device.preKey.keyId;\n            }\n            let record = await this.storage.loadSession(fqAddr);\n            if (!record) {\n                record = new SessionRecord();\n            } else {\n                const openSession = record.getOpenSession();\n                if (openSession) {\n                    console.warn(\"Closing stale open session for new outgoing prekey bundle\");\n                    record.closeSession(openSession);\n                }\n            }\n            record.setSession(session);\n            await this.storage.storeSession(fqAddr, record);\n        });\n    }\n\n    async initIncoming(record, message) {\n        const fqAddr = this.addr.toString();\n        if (!await this.storage.isTrustedIdentity(fqAddr, message.identityKey)) {\n            throw new errors.UntrustedIdentityKeyError(this.addr.id, message.identityKey);\n        }\n        if (record.getSession(message.baseKey)) {\n            // This just means we haven't replied.\n            return;\n        }\n        const preKeyPair = await this.storage.loadPreKey(message.preKeyId);\n        if (message.preKeyId && !preKeyPair) {\n            throw new errors.PreKeyError('Invalid PreKey ID');\n        }   \n        const signedPreKeyPair = await this.storage.loadSignedPreKey(message.signedPreKeyId);\n        if (!signedPreKeyPair) { \n            throw new errors.PreKeyError(\"Missing SignedPreKey\");\n        }   \n        const existingOpenSession = record.getOpenSession();\n        if (existingOpenSession) {\n            console.warn(\"Closing open session in favor of incoming prekey bundle\");\n            record.closeSession(existingOpenSession);\n        }\n        record.setSession(await this.initSession(false, preKeyPair, signedPreKeyPair,\n                                                 message.identityKey, message.baseKey,\n                                                 undefined, message.registrationId));\n        return message.preKeyId;\n    }\n\n    async initSession(isInitiator, ourEphemeralKey, ourSignedKey, theirIdentityPubKey,\n                      theirEphemeralPubKey, theirSignedPubKey, registrationId) {\n        if (isInitiator) {\n            if (ourSignedKey) {\n                throw new Error(\"Invalid call to initSession\");\n            }\n            ourSignedKey = ourEphemeralKey;\n        } else {\n            if (theirSignedPubKey) {\n                throw new Error(\"Invalid call to initSession\");\n            }\n            theirSignedPubKey = theirEphemeralPubKey;\n        }\n        let sharedSecret;\n        if (!ourEphemeralKey || !theirEphemeralPubKey) {\n            sharedSecret = new Uint8Array(32 * 4);\n        } else {\n            sharedSecret = new Uint8Array(32 * 5);\n        }\n        for (var i = 0; i < 32; i++) {\n            sharedSecret[i] = 0xff;\n        }\n        const ourIdentityKey = await this.storage.getOurIdentity();\n        const a1 = curve.calculateAgreement(theirSignedPubKey, ourIdentityKey.privKey);\n        const a2 = curve.calculateAgreement(theirIdentityPubKey, ourSignedKey.privKey);\n        const a3 = curve.calculateAgreement(theirSignedPubKey, ourSignedKey.privKey);\n        if (isInitiator) {\n            sharedSecret.set(new Uint8Array(a1), 32);\n            sharedSecret.set(new Uint8Array(a2), 32 * 2);\n        } else {\n            sharedSecret.set(new Uint8Array(a1), 32 * 2);\n            sharedSecret.set(new Uint8Array(a2), 32);\n        }\n        sharedSecret.set(new Uint8Array(a3), 32 * 3);\n        if (ourEphemeralKey && theirEphemeralPubKey) {\n            const a4 = curve.calculateAgreement(theirEphemeralPubKey, ourEphemeralKey.privKey);\n            sharedSecret.set(new Uint8Array(a4), 32 * 4);\n        }\n        const masterKey = crypto.deriveSecrets(Buffer.from(sharedSecret), Buffer.alloc(32),\n                                               Buffer.from(\"WhisperText\"));\n        const session = SessionRecord.createEntry();\n        session.registrationId = registrationId;\n        session.currentRatchet = {\n            rootKey: masterKey[0],\n            ephemeralKeyPair: isInitiator ? curve.generateKeyPair() : ourSignedKey,\n            lastRemoteEphemeralKey: theirSignedPubKey,\n            previousCounter: 0\n        };\n        session.indexInfo = {\n            created: Date.now(),\n            used: Date.now(),\n            remoteIdentityKey: theirIdentityPubKey,\n            baseKey: isInitiator ? ourEphemeralKey.pubKey : theirEphemeralPubKey,\n            baseKeyType: isInitiator ? BaseKeyType.OURS : BaseKeyType.THEIRS,\n            closed: -1\n        };\n        if (isInitiator) {\n            // If we're initiating we go ahead and set our first sending ephemeral key now,\n            // otherwise we figure it out when we first maybeStepRatchet with the remote's\n            // ephemeral key\n            this.calculateSendingRatchet(session, theirSignedPubKey);\n        }\n        return session;\n    }\n\n    calculateSendingRatchet(session, remoteKey) {\n        const ratchet = session.currentRatchet;\n        const sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);\n        const masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey, Buffer.from(\"WhisperRatchet\"));\n        session.addChain(ratchet.ephemeralKeyPair.pubKey, {\n            messageKeys: {},\n            chainKey: {\n                counter: -1,\n                key: masterKey[1]\n            },\n            chainType: ChainType.SENDING\n        });\n        ratchet.rootKey = masterKey[0];\n    }\n}\n\nmodule.exports = SessionBuilder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9zZXNzaW9uX2J1aWxkZXIuanMiLCJtYXBwaW5ncyI6IjtBQUNhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFpQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLDhEQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixlQUFlLG1CQUFPLENBQUMsOERBQVU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWE7OztBQUd0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2xpYnNpZ25hbC9zcmMvc2Vzc2lvbl9idWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlS2V5VHlwZSA9IHJlcXVpcmUoJy4vYmFzZV9rZXlfdHlwZScpO1xuY29uc3QgQ2hhaW5UeXBlID0gcmVxdWlyZSgnLi9jaGFpbl90eXBlJyk7XG5jb25zdCBTZXNzaW9uUmVjb3JkID0gcmVxdWlyZSgnLi9zZXNzaW9uX3JlY29yZCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcbmNvbnN0IGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHF1ZXVlSm9iID0gcmVxdWlyZSgnLi9xdWV1ZV9qb2InKTtcblxuXG5jbGFzcyBTZXNzaW9uQnVpbGRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBwcm90b2NvbEFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5hZGRyID0gcHJvdG9jb2xBZGRyZXNzO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIH1cblxuICAgIGFzeW5jIGluaXRPdXRnb2luZyhkZXZpY2UpIHtcbiAgICAgICAgY29uc3QgZnFBZGRyID0gdGhpcy5hZGRyLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBxdWV1ZUpvYihmcUFkZHIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghYXdhaXQgdGhpcy5zdG9yYWdlLmlzVHJ1c3RlZElkZW50aXR5KHRoaXMuYWRkci5pZCwgZGV2aWNlLmlkZW50aXR5S2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuVW50cnVzdGVkSWRlbnRpdHlLZXlFcnJvcih0aGlzLmFkZHIuaWQsIGRldmljZS5pZGVudGl0eUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJ2ZS52ZXJpZnlTaWduYXR1cmUoZGV2aWNlLmlkZW50aXR5S2V5LCBkZXZpY2Uuc2lnbmVkUHJlS2V5LnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2Uuc2lnbmVkUHJlS2V5LnNpZ25hdHVyZSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBiYXNlS2V5ID0gY3VydmUuZ2VuZXJhdGVLZXlQYWlyKCk7XG4gICAgICAgICAgICBjb25zdCBkZXZpY2VQcmVLZXkgPSBkZXZpY2UucHJlS2V5ICYmIGRldmljZS5wcmVLZXkucHVibGljS2V5O1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuaW5pdFNlc3Npb24odHJ1ZSwgYmFzZUtleSwgdW5kZWZpbmVkLCBkZXZpY2UuaWRlbnRpdHlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VQcmVLZXksIGRldmljZS5zaWduZWRQcmVLZXkucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlLnJlZ2lzdHJhdGlvbklkKTtcbiAgICAgICAgICAgIHNlc3Npb24ucGVuZGluZ1ByZUtleSA9IHtcbiAgICAgICAgICAgICAgICBzaWduZWRLZXlJZDogZGV2aWNlLnNpZ25lZFByZUtleS5rZXlJZCxcbiAgICAgICAgICAgICAgICBiYXNlS2V5OiBiYXNlS2V5LnB1YktleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkZXZpY2UucHJlS2V5KSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5wZW5kaW5nUHJlS2V5LnByZUtleUlkID0gZGV2aWNlLnByZUtleS5rZXlJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWNvcmQgPSBhd2FpdCB0aGlzLnN0b3JhZ2UubG9hZFNlc3Npb24oZnFBZGRyKTtcbiAgICAgICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gbmV3IFNlc3Npb25SZWNvcmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlblNlc3Npb24gPSByZWNvcmQuZ2V0T3BlblNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlblNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ2xvc2luZyBzdGFsZSBvcGVuIHNlc3Npb24gZm9yIG5ldyBvdXRnb2luZyBwcmVrZXkgYnVuZGxlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQuY2xvc2VTZXNzaW9uKG9wZW5TZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmQuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZVNlc3Npb24oZnFBZGRyLCByZWNvcmQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBpbml0SW5jb21pbmcocmVjb3JkLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZxQWRkciA9IHRoaXMuYWRkci50b1N0cmluZygpO1xuICAgICAgICBpZiAoIWF3YWl0IHRoaXMuc3RvcmFnZS5pc1RydXN0ZWRJZGVudGl0eShmcUFkZHIsIG1lc3NhZ2UuaWRlbnRpdHlLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlVudHJ1c3RlZElkZW50aXR5S2V5RXJyb3IodGhpcy5hZGRyLmlkLCBtZXNzYWdlLmlkZW50aXR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjb3JkLmdldFNlc3Npb24obWVzc2FnZS5iYXNlS2V5KSkge1xuICAgICAgICAgICAgLy8gVGhpcyBqdXN0IG1lYW5zIHdlIGhhdmVuJ3QgcmVwbGllZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVLZXlQYWlyID0gYXdhaXQgdGhpcy5zdG9yYWdlLmxvYWRQcmVLZXkobWVzc2FnZS5wcmVLZXlJZCk7XG4gICAgICAgIGlmIChtZXNzYWdlLnByZUtleUlkICYmICFwcmVLZXlQYWlyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlByZUtleUVycm9yKCdJbnZhbGlkIFByZUtleSBJRCcpO1xuICAgICAgICB9ICAgXG4gICAgICAgIGNvbnN0IHNpZ25lZFByZUtleVBhaXIgPSBhd2FpdCB0aGlzLnN0b3JhZ2UubG9hZFNpZ25lZFByZUtleShtZXNzYWdlLnNpZ25lZFByZUtleUlkKTtcbiAgICAgICAgaWYgKCFzaWduZWRQcmVLZXlQYWlyKSB7IFxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5QcmVLZXlFcnJvcihcIk1pc3NpbmcgU2lnbmVkUHJlS2V5XCIpO1xuICAgICAgICB9ICAgXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nT3BlblNlc3Npb24gPSByZWNvcmQuZ2V0T3BlblNlc3Npb24oKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nT3BlblNlc3Npb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNsb3Npbmcgb3BlbiBzZXNzaW9uIGluIGZhdm9yIG9mIGluY29taW5nIHByZWtleSBidW5kbGVcIik7XG4gICAgICAgICAgICByZWNvcmQuY2xvc2VTZXNzaW9uKGV4aXN0aW5nT3BlblNlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZC5zZXRTZXNzaW9uKGF3YWl0IHRoaXMuaW5pdFNlc3Npb24oZmFsc2UsIHByZUtleVBhaXIsIHNpZ25lZFByZUtleVBhaXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSwgbWVzc2FnZS5iYXNlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgbWVzc2FnZS5yZWdpc3RyYXRpb25JZCkpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5wcmVLZXlJZDtcbiAgICB9XG5cbiAgICBhc3luYyBpbml0U2Vzc2lvbihpc0luaXRpYXRvciwgb3VyRXBoZW1lcmFsS2V5LCBvdXJTaWduZWRLZXksIHRoZWlySWRlbnRpdHlQdWJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgdGhlaXJFcGhlbWVyYWxQdWJLZXksIHRoZWlyU2lnbmVkUHViS2V5LCByZWdpc3RyYXRpb25JZCkge1xuICAgICAgICBpZiAoaXNJbml0aWF0b3IpIHtcbiAgICAgICAgICAgIGlmIChvdXJTaWduZWRLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbGwgdG8gaW5pdFNlc3Npb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXJTaWduZWRLZXkgPSBvdXJFcGhlbWVyYWxLZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhlaXJTaWduZWRQdWJLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbGwgdG8gaW5pdFNlc3Npb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGVpclNpZ25lZFB1YktleSA9IHRoZWlyRXBoZW1lcmFsUHViS2V5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaGFyZWRTZWNyZXQ7XG4gICAgICAgIGlmICghb3VyRXBoZW1lcmFsS2V5IHx8ICF0aGVpckVwaGVtZXJhbFB1YktleSkge1xuICAgICAgICAgICAgc2hhcmVkU2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoMzIgKiA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlZFNlY3JldCA9IG5ldyBVaW50OEFycmF5KDMyICogNSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBzaGFyZWRTZWNyZXRbaV0gPSAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91cklkZW50aXR5S2V5ID0gYXdhaXQgdGhpcy5zdG9yYWdlLmdldE91cklkZW50aXR5KCk7XG4gICAgICAgIGNvbnN0IGExID0gY3VydmUuY2FsY3VsYXRlQWdyZWVtZW50KHRoZWlyU2lnbmVkUHViS2V5LCBvdXJJZGVudGl0eUtleS5wcml2S2V5KTtcbiAgICAgICAgY29uc3QgYTIgPSBjdXJ2ZS5jYWxjdWxhdGVBZ3JlZW1lbnQodGhlaXJJZGVudGl0eVB1YktleSwgb3VyU2lnbmVkS2V5LnByaXZLZXkpO1xuICAgICAgICBjb25zdCBhMyA9IGN1cnZlLmNhbGN1bGF0ZUFncmVlbWVudCh0aGVpclNpZ25lZFB1YktleSwgb3VyU2lnbmVkS2V5LnByaXZLZXkpO1xuICAgICAgICBpZiAoaXNJbml0aWF0b3IpIHtcbiAgICAgICAgICAgIHNoYXJlZFNlY3JldC5zZXQobmV3IFVpbnQ4QXJyYXkoYTEpLCAzMik7XG4gICAgICAgICAgICBzaGFyZWRTZWNyZXQuc2V0KG5ldyBVaW50OEFycmF5KGEyKSwgMzIgKiAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlZFNlY3JldC5zZXQobmV3IFVpbnQ4QXJyYXkoYTEpLCAzMiAqIDIpO1xuICAgICAgICAgICAgc2hhcmVkU2VjcmV0LnNldChuZXcgVWludDhBcnJheShhMiksIDMyKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFyZWRTZWNyZXQuc2V0KG5ldyBVaW50OEFycmF5KGEzKSwgMzIgKiAzKTtcbiAgICAgICAgaWYgKG91ckVwaGVtZXJhbEtleSAmJiB0aGVpckVwaGVtZXJhbFB1YktleSkge1xuICAgICAgICAgICAgY29uc3QgYTQgPSBjdXJ2ZS5jYWxjdWxhdGVBZ3JlZW1lbnQodGhlaXJFcGhlbWVyYWxQdWJLZXksIG91ckVwaGVtZXJhbEtleS5wcml2S2V5KTtcbiAgICAgICAgICAgIHNoYXJlZFNlY3JldC5zZXQobmV3IFVpbnQ4QXJyYXkoYTQpLCAzMiAqIDQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hc3RlcktleSA9IGNyeXB0by5kZXJpdmVTZWNyZXRzKEJ1ZmZlci5mcm9tKHNoYXJlZFNlY3JldCksIEJ1ZmZlci5hbGxvYygzMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKFwiV2hpc3BlclRleHRcIikpO1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gU2Vzc2lvblJlY29yZC5jcmVhdGVFbnRyeSgpO1xuICAgICAgICBzZXNzaW9uLnJlZ2lzdHJhdGlvbklkID0gcmVnaXN0cmF0aW9uSWQ7XG4gICAgICAgIHNlc3Npb24uY3VycmVudFJhdGNoZXQgPSB7XG4gICAgICAgICAgICByb290S2V5OiBtYXN0ZXJLZXlbMF0sXG4gICAgICAgICAgICBlcGhlbWVyYWxLZXlQYWlyOiBpc0luaXRpYXRvciA/IGN1cnZlLmdlbmVyYXRlS2V5UGFpcigpIDogb3VyU2lnbmVkS2V5LFxuICAgICAgICAgICAgbGFzdFJlbW90ZUVwaGVtZXJhbEtleTogdGhlaXJTaWduZWRQdWJLZXksXG4gICAgICAgICAgICBwcmV2aW91c0NvdW50ZXI6IDBcbiAgICAgICAgfTtcbiAgICAgICAgc2Vzc2lvbi5pbmRleEluZm8gPSB7XG4gICAgICAgICAgICBjcmVhdGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdXNlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHJlbW90ZUlkZW50aXR5S2V5OiB0aGVpcklkZW50aXR5UHViS2V5LFxuICAgICAgICAgICAgYmFzZUtleTogaXNJbml0aWF0b3IgPyBvdXJFcGhlbWVyYWxLZXkucHViS2V5IDogdGhlaXJFcGhlbWVyYWxQdWJLZXksXG4gICAgICAgICAgICBiYXNlS2V5VHlwZTogaXNJbml0aWF0b3IgPyBCYXNlS2V5VHlwZS5PVVJTIDogQmFzZUtleVR5cGUuVEhFSVJTLFxuICAgICAgICAgICAgY2xvc2VkOiAtMVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNJbml0aWF0b3IpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluaXRpYXRpbmcgd2UgZ28gYWhlYWQgYW5kIHNldCBvdXIgZmlyc3Qgc2VuZGluZyBlcGhlbWVyYWwga2V5IG5vdyxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBmaWd1cmUgaXQgb3V0IHdoZW4gd2UgZmlyc3QgbWF5YmVTdGVwUmF0Y2hldCB3aXRoIHRoZSByZW1vdGUnc1xuICAgICAgICAgICAgLy8gZXBoZW1lcmFsIGtleVxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVTZW5kaW5nUmF0Y2hldChzZXNzaW9uLCB0aGVpclNpZ25lZFB1YktleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlU2VuZGluZ1JhdGNoZXQoc2Vzc2lvbiwgcmVtb3RlS2V5KSB7XG4gICAgICAgIGNvbnN0IHJhdGNoZXQgPSBzZXNzaW9uLmN1cnJlbnRSYXRjaGV0O1xuICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSBjdXJ2ZS5jYWxjdWxhdGVBZ3JlZW1lbnQocmVtb3RlS2V5LCByYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHJpdktleSk7XG4gICAgICAgIGNvbnN0IG1hc3RlcktleSA9IGNyeXB0by5kZXJpdmVTZWNyZXRzKHNoYXJlZFNlY3JldCwgcmF0Y2hldC5yb290S2V5LCBCdWZmZXIuZnJvbShcIldoaXNwZXJSYXRjaGV0XCIpKTtcbiAgICAgICAgc2Vzc2lvbi5hZGRDaGFpbihyYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHViS2V5LCB7XG4gICAgICAgICAgICBtZXNzYWdlS2V5czoge30sXG4gICAgICAgICAgICBjaGFpbktleToge1xuICAgICAgICAgICAgICAgIGNvdW50ZXI6IC0xLFxuICAgICAgICAgICAgICAgIGtleTogbWFzdGVyS2V5WzFdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhaW5UeXBlOiBDaGFpblR5cGUuU0VORElOR1xuICAgICAgICB9KTtcbiAgICAgICAgcmF0Y2hldC5yb290S2V5ID0gbWFzdGVyS2V5WzBdO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXNzaW9uQnVpbGRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/session_builder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/session_cipher.js":
/*!******************************************************!*\
  !*** ./node_modules/libsignal/src/session_cipher.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// vim: ts=4:sw=4:expandtab\n\nconst ChainType = __webpack_require__(/*! ./chain_type */ \"(rsc)/./node_modules/libsignal/src/chain_type.js\");\nconst ProtocolAddress = __webpack_require__(/*! ./protocol_address */ \"(rsc)/./node_modules/libsignal/src/protocol_address.js\");\nconst SessionBuilder = __webpack_require__(/*! ./session_builder */ \"(rsc)/./node_modules/libsignal/src/session_builder.js\");\nconst SessionRecord = __webpack_require__(/*! ./session_record */ \"(rsc)/./node_modules/libsignal/src/session_record.js\");\nconst crypto = __webpack_require__(/*! ./crypto */ \"(rsc)/./node_modules/libsignal/src/crypto.js\");\nconst curve = __webpack_require__(/*! ./curve */ \"(rsc)/./node_modules/libsignal/src/curve.js\");\nconst errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/libsignal/src/errors.js\");\nconst protobufs = __webpack_require__(/*! ./protobufs */ \"(rsc)/./node_modules/libsignal/src/protobufs.js\");\nconst queueJob = __webpack_require__(/*! ./queue_job */ \"(rsc)/./node_modules/libsignal/src/queue_job.js\");\n\nconst VERSION = 3;\n\nfunction assertBuffer(value) {\n    if (!(value instanceof Buffer)) {\n        throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);\n    }\n    return value;\n}\n\n\nclass SessionCipher {\n\n    constructor(storage, protocolAddress) {\n        if (!(protocolAddress instanceof ProtocolAddress)) {\n            throw new TypeError(\"protocolAddress must be a ProtocolAddress\");\n        }\n        this.addr = protocolAddress;\n        this.storage = storage;\n    }\n\n    _encodeTupleByte(number1, number2) {\n        if (number1 > 15 || number2 > 15) {\n            throw TypeError(\"Numbers must be 4 bits or less\");\n        }\n        return (number1 << 4) | number2;\n    }\n\n    _decodeTupleByte(byte) {\n        return [byte >> 4, byte & 0xf];\n    }\n\n    toString() {\n        return `<SessionCipher(${this.addr.toString()})>`;\n    }\n\n    async getRecord() {\n        const record = await this.storage.loadSession(this.addr.toString());\n        if (record && !(record instanceof SessionRecord)) {\n            throw new TypeError('SessionRecord type expected from loadSession'); \n        }\n        return record;\n    }\n\n    async storeRecord(record) {\n        record.removeOldSessions();\n        await this.storage.storeSession(this.addr.toString(), record);\n    }\n\n    async queueJob(awaitable) {\n        return await queueJob(this.addr.toString(), awaitable);\n    }\n\n    async encrypt(data) {\n        assertBuffer(data);\n        const ourIdentityKey = await this.storage.getOurIdentity();\n        return await this.queueJob(async () => {\n            const record = await this.getRecord();\n            if (!record) {\n                throw new errors.SessionError(\"No sessions\");\n            }\n            const session = record.getOpenSession();\n            if (!session) {\n                throw new errors.SessionError(\"No open session\");\n            }\n            const remoteIdentityKey = session.indexInfo.remoteIdentityKey;\n            if (!await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey)) {\n                throw new errors.UntrustedIdentityKeyError(this.addr.id, remoteIdentityKey);\n            }\n            const chain = session.getChain(session.currentRatchet.ephemeralKeyPair.pubKey);\n            if (chain.chainType === ChainType.RECEIVING) {\n                throw new Error(\"Tried to encrypt on a receiving chain\");\n            }\n            this.fillMessageKeys(chain, chain.chainKey.counter + 1);\n            const keys = crypto.deriveSecrets(chain.messageKeys[chain.chainKey.counter],\n                                              Buffer.alloc(32), Buffer.from(\"WhisperMessageKeys\"));\n            delete chain.messageKeys[chain.chainKey.counter];\n            const msg = protobufs.WhisperMessage.create();\n            msg.ephemeralKey = session.currentRatchet.ephemeralKeyPair.pubKey;\n            msg.counter = chain.chainKey.counter;\n            msg.previousCounter = session.currentRatchet.previousCounter;\n            msg.ciphertext = crypto.encrypt(keys[0], data, keys[2].slice(0, 16));\n            const msgBuf = protobufs.WhisperMessage.encode(msg).finish();\n            const macInput = Buffer.alloc(msgBuf.byteLength + (33 * 2) + 1);\n            macInput.set(ourIdentityKey.pubKey);\n            macInput.set(session.indexInfo.remoteIdentityKey, 33);\n            macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);\n            macInput.set(msgBuf, (33 * 2) + 1);\n            const mac = crypto.calculateMAC(keys[1], macInput);\n            const result = Buffer.alloc(msgBuf.byteLength + 9);\n            result[0] = this._encodeTupleByte(VERSION, VERSION);\n            result.set(msgBuf, 1);\n            result.set(mac.slice(0, 8), msgBuf.byteLength + 1);\n            await this.storeRecord(record);\n            let type, body;\n            if (session.pendingPreKey) {\n                type = 3;  // prekey bundle\n                const preKeyMsg = protobufs.PreKeyWhisperMessage.create({\n                    identityKey: ourIdentityKey.pubKey,\n                    registrationId: await this.storage.getOurRegistrationId(),\n                    baseKey: session.pendingPreKey.baseKey,\n                    signedPreKeyId: session.pendingPreKey.signedKeyId,\n                    message: result\n                });\n                if (session.pendingPreKey.preKeyId) {\n                    preKeyMsg.preKeyId = session.pendingPreKey.preKeyId;\n                }\n                body = Buffer.concat([\n                    Buffer.from([this._encodeTupleByte(VERSION, VERSION)]),\n                    Buffer.from(\n                        protobufs.PreKeyWhisperMessage.encode(preKeyMsg).finish()\n                    )\n                ]);\n            } else {\n                type = 1;  // normal\n                body = result;\n            }\n            return {\n                type,\n                body,\n                registrationId: session.registrationId\n            };\n        });\n    }\n\n    async decryptWithSessions(data, sessions) {\n        // Iterate through the sessions, attempting to decrypt using each one.\n        // Stop and return the result if we get a valid result.\n        if (!sessions.length) {\n            throw new errors.SessionError(\"No sessions available\");\n        }   \n        const errs = [];\n        for (const session of sessions) {\n            let plaintext; \n            try {\n                plaintext = await this.doDecryptWhisperMessage(data, session);\n                session.indexInfo.used = Date.now();\n                return {\n                    session,\n                    plaintext\n                };\n            } catch(e) {\n                errs.push(e);\n            }\n        }\n        console.error(\"Failed to decrypt message with any known session...\");\n        for (const e of errs) {\n            console.error(\"Session error:\" + e, e.stack);\n        }\n        throw new errors.SessionError(\"No matching sessions found for message\");\n    }\n\n    async decryptWhisperMessage(data) {\n        assertBuffer(data);\n        return await this.queueJob(async () => {\n            const record = await this.getRecord();\n            if (!record) {\n                throw new errors.SessionError(\"No session record\");\n            }\n            const result = await this.decryptWithSessions(data, record.getSessions());\n            const remoteIdentityKey = result.session.indexInfo.remoteIdentityKey;\n            if (!await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey)) {\n                throw new errors.UntrustedIdentityKeyError(this.addr.id, remoteIdentityKey);\n            }   \n            if (record.isClosed(result.session)) {\n                // It's possible for this to happen when processing a backlog of messages.\n                // The message was, hopefully, just sent back in a time when this session\n                // was the most current.  Simply make a note of it and continue.  If our\n                // actual open session is for reason invalid, that must be handled via\n                // a full SessionError response.\n                console.warn(\"Decrypted message with closed session.\");\n            }\n            await this.storeRecord(record);\n            return result.plaintext;\n        });\n    }\n\n    async decryptPreKeyWhisperMessage(data) {\n        assertBuffer(data);\n        const versions = this._decodeTupleByte(data[0]);\n        if (versions[1] > 3 || versions[0] < 3) {  // min version > 3 or max version < 3\n            throw new Error(\"Incompatible version number on PreKeyWhisperMessage\");\n        }\n        return await this.queueJob(async () => {\n            let record = await this.getRecord();\n            const preKeyProto = protobufs.PreKeyWhisperMessage.decode(data.slice(1));\n            if (!record) {\n                if (preKeyProto.registrationId == null) {\n                    throw new Error(\"No registrationId\");\n                }\n                record = new SessionRecord();\n            }\n            const builder = new SessionBuilder(this.storage, this.addr);\n            const preKeyId = await builder.initIncoming(record, preKeyProto);\n            const session = record.getSession(preKeyProto.baseKey);\n            const plaintext = await this.doDecryptWhisperMessage(preKeyProto.message, session);\n            await this.storeRecord(record);\n            if (preKeyId) {\n                await this.storage.removePreKey(preKeyId);\n            }\n            return plaintext;\n        });\n    }\n\n    async doDecryptWhisperMessage(messageBuffer, session) {\n        assertBuffer(messageBuffer);\n        if (!session) {\n            throw new TypeError(\"session required\");\n        }\n        const versions = this._decodeTupleByte(messageBuffer[0]);\n        if (versions[1] > 3 || versions[0] < 3) {  // min version > 3 or max version < 3\n            throw new Error(\"Incompatible version number on WhisperMessage\");\n        }\n        const messageProto = messageBuffer.slice(1, -8);\n        const message = protobufs.WhisperMessage.decode(messageProto);\n        this.maybeStepRatchet(session, message.ephemeralKey, message.previousCounter);\n        const chain = session.getChain(message.ephemeralKey);\n        if (chain.chainType === ChainType.SENDING) {\n            throw new Error(\"Tried to decrypt on a sending chain\");\n        }\n        this.fillMessageKeys(chain, message.counter);\n        if (!chain.messageKeys.hasOwnProperty(message.counter)) {\n            // Most likely the message was already decrypted and we are trying to process\n            // twice.  This can happen if the user restarts before the server gets an ACK.\n            throw new errors.MessageCounterError('Key used already or never filled');\n        }\n        const messageKey = chain.messageKeys[message.counter];\n        delete chain.messageKeys[message.counter];\n        const keys = crypto.deriveSecrets(messageKey, Buffer.alloc(32),\n                                          Buffer.from(\"WhisperMessageKeys\"));\n        const ourIdentityKey = await this.storage.getOurIdentity();\n        const macInput = Buffer.alloc(messageProto.byteLength + (33 * 2) + 1);\n        macInput.set(session.indexInfo.remoteIdentityKey);\n        macInput.set(ourIdentityKey.pubKey, 33);\n        macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);\n        macInput.set(messageProto, (33 * 2) + 1);\n        // This is where we most likely fail if the session is not a match.\n        // Don't misinterpret this as corruption.\n        crypto.verifyMAC(macInput, keys[1], messageBuffer.slice(-8), 8);\n        const plaintext = crypto.decrypt(keys[0], message.ciphertext, keys[2].slice(0, 16));\n        delete session.pendingPreKey;\n        return plaintext;\n    }\n\n    fillMessageKeys(chain, counter) {\n        if (chain.chainKey.counter >= counter) {\n            return;\n        }\n        if (counter - chain.chainKey.counter > 2000) {\n            throw new errors.SessionError('Over 2000 messages into the future!');\n        }\n        if (chain.chainKey.key === undefined) {\n            throw new errors.SessionError('Chain closed');\n        }\n        const key = chain.chainKey.key;\n        chain.messageKeys[chain.chainKey.counter + 1] = crypto.calculateMAC(key, Buffer.from([1]));\n        chain.chainKey.key = crypto.calculateMAC(key, Buffer.from([2]));\n        chain.chainKey.counter += 1;\n        return this.fillMessageKeys(chain, counter);\n    }\n\n    maybeStepRatchet(session, remoteKey, previousCounter) {\n        if (session.getChain(remoteKey)) {\n            return;\n        }\n        const ratchet = session.currentRatchet;\n        let previousRatchet = session.getChain(ratchet.lastRemoteEphemeralKey);\n        if (previousRatchet) {\n            this.fillMessageKeys(previousRatchet, previousCounter);\n            delete previousRatchet.chainKey.key;  // Close\n        }\n        this.calculateRatchet(session, remoteKey, false);\n        // Now swap the ephemeral key and calculate the new sending chain\n        const prevCounter = session.getChain(ratchet.ephemeralKeyPair.pubKey);\n        if (prevCounter) {\n            ratchet.previousCounter = prevCounter.chainKey.counter;\n            session.deleteChain(ratchet.ephemeralKeyPair.pubKey);\n        }\n        ratchet.ephemeralKeyPair = curve.generateKeyPair();\n        this.calculateRatchet(session, remoteKey, true);\n        ratchet.lastRemoteEphemeralKey = remoteKey;\n    }\n\n    calculateRatchet(session, remoteKey, sending) {\n        let ratchet = session.currentRatchet;\n        const sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);\n        const masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey,\n                                               Buffer.from(\"WhisperRatchet\"), /*chunks*/ 2);\n        const chainKey = sending ? ratchet.ephemeralKeyPair.pubKey : remoteKey;\n        session.addChain(chainKey, {\n            messageKeys: {},\n            chainKey: {\n                counter: -1,\n                key: masterKey[1]\n            },\n            chainType: sending ? ChainType.SENDING : ChainType.RECEIVING\n        });\n        ratchet.rootKey = masterKey[0];\n    }\n\n    async hasOpenSession() {\n        return await this.queueJob(async () => {\n            const record = await this.getRecord();\n            if (!record) {\n                return false;\n            }\n            return record.haveOpenSession();\n        });\n    }\n\n    async closeOpenSession() {\n        return await this.queueJob(async () => {\n            const record = await this.getRecord();\n            if (record) {\n                const openSession = record.getOpenSession();\n                if (openSession) {\n                    record.closeSession(openSession);\n                    await this.storeRecord(record);\n                }\n            }\n        });\n    }\n}\n\nmodule.exports = SessionCipher;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9zZXNzaW9uX2NpcGhlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4Qyx3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBb0I7QUFDcEQsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ2xELHNCQUFzQixtQkFBTyxDQUFDLDhFQUFrQjtBQUNoRCxlQUFlLG1CQUFPLENBQUMsOERBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLDREQUFTO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyw4REFBVTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBYTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBYTs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCx1QkFBdUI7QUFDOUU7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2xpYnNpZ25hbC9zcmMvc2Vzc2lvbl9jaXBoZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdmltOiB0cz00OnN3PTQ6ZXhwYW5kdGFiXG5cbmNvbnN0IENoYWluVHlwZSA9IHJlcXVpcmUoJy4vY2hhaW5fdHlwZScpO1xuY29uc3QgUHJvdG9jb2xBZGRyZXNzID0gcmVxdWlyZSgnLi9wcm90b2NvbF9hZGRyZXNzJyk7XG5jb25zdCBTZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoJy4vc2Vzc2lvbl9idWlsZGVyJyk7XG5jb25zdCBTZXNzaW9uUmVjb3JkID0gcmVxdWlyZSgnLi9zZXNzaW9uX3JlY29yZCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcbmNvbnN0IGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IHByb3RvYnVmcyA9IHJlcXVpcmUoJy4vcHJvdG9idWZzJyk7XG5jb25zdCBxdWV1ZUpvYiA9IHJlcXVpcmUoJy4vcXVldWVfam9iJyk7XG5cbmNvbnN0IFZFUlNJT04gPSAzO1xuXG5mdW5jdGlvbiBhc3NlcnRCdWZmZXIodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGBFeHBlY3RlZCBCdWZmZXIgaW5zdGVhZCBvZjogJHt2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cblxuY2xhc3MgU2Vzc2lvbkNpcGhlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBwcm90b2NvbEFkZHJlc3MpIHtcbiAgICAgICAgaWYgKCEocHJvdG9jb2xBZGRyZXNzIGluc3RhbmNlb2YgUHJvdG9jb2xBZGRyZXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3RvY29sQWRkcmVzcyBtdXN0IGJlIGEgUHJvdG9jb2xBZGRyZXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkciA9IHByb3RvY29sQWRkcmVzcztcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB9XG5cbiAgICBfZW5jb2RlVHVwbGVCeXRlKG51bWJlcjEsIG51bWJlcjIpIHtcbiAgICAgICAgaWYgKG51bWJlcjEgPiAxNSB8fCBudW1iZXIyID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk51bWJlcnMgbXVzdCBiZSA0IGJpdHMgb3IgbGVzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG51bWJlcjEgPDwgNCkgfCBudW1iZXIyO1xuICAgIH1cblxuICAgIF9kZWNvZGVUdXBsZUJ5dGUoYnl0ZSkge1xuICAgICAgICByZXR1cm4gW2J5dGUgPj4gNCwgYnl0ZSAmIDB4Zl07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPFNlc3Npb25DaXBoZXIoJHt0aGlzLmFkZHIudG9TdHJpbmcoKX0pPmA7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0UmVjb3JkKCkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSBhd2FpdCB0aGlzLnN0b3JhZ2UubG9hZFNlc3Npb24odGhpcy5hZGRyLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAocmVjb3JkICYmICEocmVjb3JkIGluc3RhbmNlb2YgU2Vzc2lvblJlY29yZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Nlc3Npb25SZWNvcmQgdHlwZSBleHBlY3RlZCBmcm9tIGxvYWRTZXNzaW9uJyk7IFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfVxuXG4gICAgYXN5bmMgc3RvcmVSZWNvcmQocmVjb3JkKSB7XG4gICAgICAgIHJlY29yZC5yZW1vdmVPbGRTZXNzaW9ucygpO1xuICAgICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc3RvcmVTZXNzaW9uKHRoaXMuYWRkci50b1N0cmluZygpLCByZWNvcmQpO1xuICAgIH1cblxuICAgIGFzeW5jIHF1ZXVlSm9iKGF3YWl0YWJsZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcXVldWVKb2IodGhpcy5hZGRyLnRvU3RyaW5nKCksIGF3YWl0YWJsZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZW5jcnlwdChkYXRhKSB7XG4gICAgICAgIGFzc2VydEJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3Qgb3VySWRlbnRpdHlLZXkgPSBhd2FpdCB0aGlzLnN0b3JhZ2UuZ2V0T3VySWRlbnRpdHkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucXVldWVKb2IoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gYXdhaXQgdGhpcy5nZXRSZWNvcmQoKTtcbiAgICAgICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5TZXNzaW9uRXJyb3IoXCJObyBzZXNzaW9uc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSByZWNvcmQuZ2V0T3BlblNlc3Npb24oKTtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuU2Vzc2lvbkVycm9yKFwiTm8gb3BlbiBzZXNzaW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVtb3RlSWRlbnRpdHlLZXkgPSBzZXNzaW9uLmluZGV4SW5mby5yZW1vdGVJZGVudGl0eUtleTtcbiAgICAgICAgICAgIGlmICghYXdhaXQgdGhpcy5zdG9yYWdlLmlzVHJ1c3RlZElkZW50aXR5KHRoaXMuYWRkci5pZCwgcmVtb3RlSWRlbnRpdHlLZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5VbnRydXN0ZWRJZGVudGl0eUtleUVycm9yKHRoaXMuYWRkci5pZCwgcmVtb3RlSWRlbnRpdHlLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBzZXNzaW9uLmdldENoYWluKHNlc3Npb24uY3VycmVudFJhdGNoZXQuZXBoZW1lcmFsS2V5UGFpci5wdWJLZXkpO1xuICAgICAgICAgICAgaWYgKGNoYWluLmNoYWluVHlwZSA9PT0gQ2hhaW5UeXBlLlJFQ0VJVklORykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGVuY3J5cHQgb24gYSByZWNlaXZpbmcgY2hhaW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpbGxNZXNzYWdlS2V5cyhjaGFpbiwgY2hhaW4uY2hhaW5LZXkuY291bnRlciArIDEpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5kZXJpdmVTZWNyZXRzKGNoYWluLm1lc3NhZ2VLZXlzW2NoYWluLmNoYWluS2V5LmNvdW50ZXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5hbGxvYygzMiksIEJ1ZmZlci5mcm9tKFwiV2hpc3Blck1lc3NhZ2VLZXlzXCIpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFpbi5tZXNzYWdlS2V5c1tjaGFpbi5jaGFpbktleS5jb3VudGVyXTtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHByb3RvYnVmcy5XaGlzcGVyTWVzc2FnZS5jcmVhdGUoKTtcbiAgICAgICAgICAgIG1zZy5lcGhlbWVyYWxLZXkgPSBzZXNzaW9uLmN1cnJlbnRSYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHViS2V5O1xuICAgICAgICAgICAgbXNnLmNvdW50ZXIgPSBjaGFpbi5jaGFpbktleS5jb3VudGVyO1xuICAgICAgICAgICAgbXNnLnByZXZpb3VzQ291bnRlciA9IHNlc3Npb24uY3VycmVudFJhdGNoZXQucHJldmlvdXNDb3VudGVyO1xuICAgICAgICAgICAgbXNnLmNpcGhlcnRleHQgPSBjcnlwdG8uZW5jcnlwdChrZXlzWzBdLCBkYXRhLCBrZXlzWzJdLnNsaWNlKDAsIDE2KSk7XG4gICAgICAgICAgICBjb25zdCBtc2dCdWYgPSBwcm90b2J1ZnMuV2hpc3Blck1lc3NhZ2UuZW5jb2RlKG1zZykuZmluaXNoKCk7XG4gICAgICAgICAgICBjb25zdCBtYWNJbnB1dCA9IEJ1ZmZlci5hbGxvYyhtc2dCdWYuYnl0ZUxlbmd0aCArICgzMyAqIDIpICsgMSk7XG4gICAgICAgICAgICBtYWNJbnB1dC5zZXQob3VySWRlbnRpdHlLZXkucHViS2V5KTtcbiAgICAgICAgICAgIG1hY0lucHV0LnNldChzZXNzaW9uLmluZGV4SW5mby5yZW1vdGVJZGVudGl0eUtleSwgMzMpO1xuICAgICAgICAgICAgbWFjSW5wdXRbMzMgKiAyXSA9IHRoaXMuX2VuY29kZVR1cGxlQnl0ZShWRVJTSU9OLCBWRVJTSU9OKTtcbiAgICAgICAgICAgIG1hY0lucHV0LnNldChtc2dCdWYsICgzMyAqIDIpICsgMSk7XG4gICAgICAgICAgICBjb25zdCBtYWMgPSBjcnlwdG8uY2FsY3VsYXRlTUFDKGtleXNbMV0sIG1hY0lucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhtc2dCdWYuYnl0ZUxlbmd0aCArIDkpO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGhpcy5fZW5jb2RlVHVwbGVCeXRlKFZFUlNJT04sIFZFUlNJT04pO1xuICAgICAgICAgICAgcmVzdWx0LnNldChtc2dCdWYsIDEpO1xuICAgICAgICAgICAgcmVzdWx0LnNldChtYWMuc2xpY2UoMCwgOCksIG1zZ0J1Zi5ieXRlTGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JlUmVjb3JkKHJlY29yZCk7XG4gICAgICAgICAgICBsZXQgdHlwZSwgYm9keTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnBlbmRpbmdQcmVLZXkpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gMzsgIC8vIHByZWtleSBidW5kbGVcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVLZXlNc2cgPSBwcm90b2J1ZnMuUHJlS2V5V2hpc3Blck1lc3NhZ2UuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHlLZXk6IG91cklkZW50aXR5S2V5LnB1YktleSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uSWQ6IGF3YWl0IHRoaXMuc3RvcmFnZS5nZXRPdXJSZWdpc3RyYXRpb25JZCgpLFxuICAgICAgICAgICAgICAgICAgICBiYXNlS2V5OiBzZXNzaW9uLnBlbmRpbmdQcmVLZXkuYmFzZUtleSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVkUHJlS2V5SWQ6IHNlc3Npb24ucGVuZGluZ1ByZUtleS5zaWduZWRLZXlJZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24ucGVuZGluZ1ByZUtleS5wcmVLZXlJZCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVLZXlNc2cucHJlS2V5SWQgPSBzZXNzaW9uLnBlbmRpbmdQcmVLZXkucHJlS2V5SWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20oW3RoaXMuX2VuY29kZVR1cGxlQnl0ZShWRVJTSU9OLCBWRVJTSU9OKV0pLFxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvYnVmcy5QcmVLZXlXaGlzcGVyTWVzc2FnZS5lbmNvZGUocHJlS2V5TXNnKS5maW5pc2goKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAxOyAgLy8gbm9ybWFsXG4gICAgICAgICAgICAgICAgYm9keSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvbklkOiBzZXNzaW9uLnJlZ2lzdHJhdGlvbklkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWNyeXB0V2l0aFNlc3Npb25zKGRhdGEsIHNlc3Npb25zKSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc2Vzc2lvbnMsIGF0dGVtcHRpbmcgdG8gZGVjcnlwdCB1c2luZyBlYWNoIG9uZS5cbiAgICAgICAgLy8gU3RvcCBhbmQgcmV0dXJuIHRoZSByZXN1bHQgaWYgd2UgZ2V0IGEgdmFsaWQgcmVzdWx0LlxuICAgICAgICBpZiAoIXNlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5TZXNzaW9uRXJyb3IoXCJObyBzZXNzaW9ucyBhdmFpbGFibGVcIik7XG4gICAgICAgIH0gICBcbiAgICAgICAgY29uc3QgZXJycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2Vzc2lvbnMpIHtcbiAgICAgICAgICAgIGxldCBwbGFpbnRleHQ7IFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgPSBhd2FpdCB0aGlzLmRvRGVjcnlwdFdoaXNwZXJNZXNzYWdlKGRhdGEsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uaW5kZXhJbmZvLnVzZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHBsYWludGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJzLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IG1lc3NhZ2Ugd2l0aCBhbnkga25vd24gc2Vzc2lvbi4uLlwiKTtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVycnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTZXNzaW9uIGVycm9yOlwiICsgZSwgZS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5TZXNzaW9uRXJyb3IoXCJObyBtYXRjaGluZyBzZXNzaW9ucyBmb3VuZCBmb3IgbWVzc2FnZVwiKTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWNyeXB0V2hpc3Blck1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBhc3NlcnRCdWZmZXIoZGF0YSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXVlSm9iKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IHRoaXMuZ2V0UmVjb3JkKCk7XG4gICAgICAgICAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuU2Vzc2lvbkVycm9yKFwiTm8gc2Vzc2lvbiByZWNvcmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRlY3J5cHRXaXRoU2Vzc2lvbnMoZGF0YSwgcmVjb3JkLmdldFNlc3Npb25zKCkpO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlSWRlbnRpdHlLZXkgPSByZXN1bHQuc2Vzc2lvbi5pbmRleEluZm8ucmVtb3RlSWRlbnRpdHlLZXk7XG4gICAgICAgICAgICBpZiAoIWF3YWl0IHRoaXMuc3RvcmFnZS5pc1RydXN0ZWRJZGVudGl0eSh0aGlzLmFkZHIuaWQsIHJlbW90ZUlkZW50aXR5S2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuVW50cnVzdGVkSWRlbnRpdHlLZXlFcnJvcih0aGlzLmFkZHIuaWQsIHJlbW90ZUlkZW50aXR5S2V5KTtcbiAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgIGlmIChyZWNvcmQuaXNDbG9zZWQocmVzdWx0LnNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBwb3NzaWJsZSBmb3IgdGhpcyB0byBoYXBwZW4gd2hlbiBwcm9jZXNzaW5nIGEgYmFja2xvZyBvZiBtZXNzYWdlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGUgbWVzc2FnZSB3YXMsIGhvcGVmdWxseSwganVzdCBzZW50IGJhY2sgaW4gYSB0aW1lIHdoZW4gdGhpcyBzZXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gd2FzIHRoZSBtb3N0IGN1cnJlbnQuICBTaW1wbHkgbWFrZSBhIG5vdGUgb2YgaXQgYW5kIGNvbnRpbnVlLiAgSWYgb3VyXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsIG9wZW4gc2Vzc2lvbiBpcyBmb3IgcmVhc29uIGludmFsaWQsIHRoYXQgbXVzdCBiZSBoYW5kbGVkIHZpYVxuICAgICAgICAgICAgICAgIC8vIGEgZnVsbCBTZXNzaW9uRXJyb3IgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGVjcnlwdGVkIG1lc3NhZ2Ugd2l0aCBjbG9zZWQgc2Vzc2lvbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JlUmVjb3JkKHJlY29yZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnBsYWludGV4dDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGVjcnlwdFByZUtleVdoaXNwZXJNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IHRoaXMuX2RlY29kZVR1cGxlQnl0ZShkYXRhWzBdKTtcbiAgICAgICAgaWYgKHZlcnNpb25zWzFdID4gMyB8fCB2ZXJzaW9uc1swXSA8IDMpIHsgIC8vIG1pbiB2ZXJzaW9uID4gMyBvciBtYXggdmVyc2lvbiA8IDNcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGF0aWJsZSB2ZXJzaW9uIG51bWJlciBvbiBQcmVLZXlXaGlzcGVyTWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWV1ZUpvYihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjb3JkID0gYXdhaXQgdGhpcy5nZXRSZWNvcmQoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZUtleVByb3RvID0gcHJvdG9idWZzLlByZUtleVdoaXNwZXJNZXNzYWdlLmRlY29kZShkYXRhLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZUtleVByb3RvLnJlZ2lzdHJhdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVnaXN0cmF0aW9uSWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY29yZCA9IG5ldyBTZXNzaW9uUmVjb3JkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWlsZGVyID0gbmV3IFNlc3Npb25CdWlsZGVyKHRoaXMuc3RvcmFnZSwgdGhpcy5hZGRyKTtcbiAgICAgICAgICAgIGNvbnN0IHByZUtleUlkID0gYXdhaXQgYnVpbGRlci5pbml0SW5jb21pbmcocmVjb3JkLCBwcmVLZXlQcm90byk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gcmVjb3JkLmdldFNlc3Npb24ocHJlS2V5UHJvdG8uYmFzZUtleSk7XG4gICAgICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBhd2FpdCB0aGlzLmRvRGVjcnlwdFdoaXNwZXJNZXNzYWdlKHByZUtleVByb3RvLm1lc3NhZ2UsIHNlc3Npb24pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdG9yZVJlY29yZChyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKHByZUtleUlkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdG9yYWdlLnJlbW92ZVByZUtleShwcmVLZXlJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBkb0RlY3J5cHRXaGlzcGVyTWVzc2FnZShtZXNzYWdlQnVmZmVyLCBzZXNzaW9uKSB7XG4gICAgICAgIGFzc2VydEJ1ZmZlcihtZXNzYWdlQnVmZmVyKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2Vzc2lvbiByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IHRoaXMuX2RlY29kZVR1cGxlQnl0ZShtZXNzYWdlQnVmZmVyWzBdKTtcbiAgICAgICAgaWYgKHZlcnNpb25zWzFdID4gMyB8fCB2ZXJzaW9uc1swXSA8IDMpIHsgIC8vIG1pbiB2ZXJzaW9uID4gMyBvciBtYXggdmVyc2lvbiA8IDNcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGF0aWJsZSB2ZXJzaW9uIG51bWJlciBvbiBXaGlzcGVyTWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlUHJvdG8gPSBtZXNzYWdlQnVmZmVyLnNsaWNlKDEsIC04KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHByb3RvYnVmcy5XaGlzcGVyTWVzc2FnZS5kZWNvZGUobWVzc2FnZVByb3RvKTtcbiAgICAgICAgdGhpcy5tYXliZVN0ZXBSYXRjaGV0KHNlc3Npb24sIG1lc3NhZ2UuZXBoZW1lcmFsS2V5LCBtZXNzYWdlLnByZXZpb3VzQ291bnRlcik7XG4gICAgICAgIGNvbnN0IGNoYWluID0gc2Vzc2lvbi5nZXRDaGFpbihtZXNzYWdlLmVwaGVtZXJhbEtleSk7XG4gICAgICAgIGlmIChjaGFpbi5jaGFpblR5cGUgPT09IENoYWluVHlwZS5TRU5ESU5HKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBkZWNyeXB0IG9uIGEgc2VuZGluZyBjaGFpblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGxNZXNzYWdlS2V5cyhjaGFpbiwgbWVzc2FnZS5jb3VudGVyKTtcbiAgICAgICAgaWYgKCFjaGFpbi5tZXNzYWdlS2V5cy5oYXNPd25Qcm9wZXJ0eShtZXNzYWdlLmNvdW50ZXIpKSB7XG4gICAgICAgICAgICAvLyBNb3N0IGxpa2VseSB0aGUgbWVzc2FnZSB3YXMgYWxyZWFkeSBkZWNyeXB0ZWQgYW5kIHdlIGFyZSB0cnlpbmcgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgLy8gdHdpY2UuICBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHVzZXIgcmVzdGFydHMgYmVmb3JlIHRoZSBzZXJ2ZXIgZ2V0cyBhbiBBQ0suXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLk1lc3NhZ2VDb3VudGVyRXJyb3IoJ0tleSB1c2VkIGFscmVhZHkgb3IgbmV2ZXIgZmlsbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZUtleSA9IGNoYWluLm1lc3NhZ2VLZXlzW21lc3NhZ2UuY291bnRlcl07XG4gICAgICAgIGRlbGV0ZSBjaGFpbi5tZXNzYWdlS2V5c1ttZXNzYWdlLmNvdW50ZXJdO1xuICAgICAgICBjb25zdCBrZXlzID0gY3J5cHRvLmRlcml2ZVNlY3JldHMobWVzc2FnZUtleSwgQnVmZmVyLmFsbG9jKDMyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKFwiV2hpc3Blck1lc3NhZ2VLZXlzXCIpKTtcbiAgICAgICAgY29uc3Qgb3VySWRlbnRpdHlLZXkgPSBhd2FpdCB0aGlzLnN0b3JhZ2UuZ2V0T3VySWRlbnRpdHkoKTtcbiAgICAgICAgY29uc3QgbWFjSW5wdXQgPSBCdWZmZXIuYWxsb2MobWVzc2FnZVByb3RvLmJ5dGVMZW5ndGggKyAoMzMgKiAyKSArIDEpO1xuICAgICAgICBtYWNJbnB1dC5zZXQoc2Vzc2lvbi5pbmRleEluZm8ucmVtb3RlSWRlbnRpdHlLZXkpO1xuICAgICAgICBtYWNJbnB1dC5zZXQob3VySWRlbnRpdHlLZXkucHViS2V5LCAzMyk7XG4gICAgICAgIG1hY0lucHV0WzMzICogMl0gPSB0aGlzLl9lbmNvZGVUdXBsZUJ5dGUoVkVSU0lPTiwgVkVSU0lPTik7XG4gICAgICAgIG1hY0lucHV0LnNldChtZXNzYWdlUHJvdG8sICgzMyAqIDIpICsgMSk7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgd2UgbW9zdCBsaWtlbHkgZmFpbCBpZiB0aGUgc2Vzc2lvbiBpcyBub3QgYSBtYXRjaC5cbiAgICAgICAgLy8gRG9uJ3QgbWlzaW50ZXJwcmV0IHRoaXMgYXMgY29ycnVwdGlvbi5cbiAgICAgICAgY3J5cHRvLnZlcmlmeU1BQyhtYWNJbnB1dCwga2V5c1sxXSwgbWVzc2FnZUJ1ZmZlci5zbGljZSgtOCksIDgpO1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBjcnlwdG8uZGVjcnlwdChrZXlzWzBdLCBtZXNzYWdlLmNpcGhlcnRleHQsIGtleXNbMl0uc2xpY2UoMCwgMTYpKTtcbiAgICAgICAgZGVsZXRlIHNlc3Npb24ucGVuZGluZ1ByZUtleTtcbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG5cbiAgICBmaWxsTWVzc2FnZUtleXMoY2hhaW4sIGNvdW50ZXIpIHtcbiAgICAgICAgaWYgKGNoYWluLmNoYWluS2V5LmNvdW50ZXIgPj0gY291bnRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudGVyIC0gY2hhaW4uY2hhaW5LZXkuY291bnRlciA+IDIwMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuU2Vzc2lvbkVycm9yKCdPdmVyIDIwMDAgbWVzc2FnZXMgaW50byB0aGUgZnV0dXJlIScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFpbi5jaGFpbktleS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5TZXNzaW9uRXJyb3IoJ0NoYWluIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IGNoYWluLmNoYWluS2V5LmtleTtcbiAgICAgICAgY2hhaW4ubWVzc2FnZUtleXNbY2hhaW4uY2hhaW5LZXkuY291bnRlciArIDFdID0gY3J5cHRvLmNhbGN1bGF0ZU1BQyhrZXksIEJ1ZmZlci5mcm9tKFsxXSkpO1xuICAgICAgICBjaGFpbi5jaGFpbktleS5rZXkgPSBjcnlwdG8uY2FsY3VsYXRlTUFDKGtleSwgQnVmZmVyLmZyb20oWzJdKSk7XG4gICAgICAgIGNoYWluLmNoYWluS2V5LmNvdW50ZXIgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbE1lc3NhZ2VLZXlzKGNoYWluLCBjb3VudGVyKTtcbiAgICB9XG5cbiAgICBtYXliZVN0ZXBSYXRjaGV0KHNlc3Npb24sIHJlbW90ZUtleSwgcHJldmlvdXNDb3VudGVyKSB7XG4gICAgICAgIGlmIChzZXNzaW9uLmdldENoYWluKHJlbW90ZUtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXRjaGV0ID0gc2Vzc2lvbi5jdXJyZW50UmF0Y2hldDtcbiAgICAgICAgbGV0IHByZXZpb3VzUmF0Y2hldCA9IHNlc3Npb24uZ2V0Q2hhaW4ocmF0Y2hldC5sYXN0UmVtb3RlRXBoZW1lcmFsS2V5KTtcbiAgICAgICAgaWYgKHByZXZpb3VzUmF0Y2hldCkge1xuICAgICAgICAgICAgdGhpcy5maWxsTWVzc2FnZUtleXMocHJldmlvdXNSYXRjaGV0LCBwcmV2aW91c0NvdW50ZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHByZXZpb3VzUmF0Y2hldC5jaGFpbktleS5rZXk7ICAvLyBDbG9zZVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmF0Y2hldChzZXNzaW9uLCByZW1vdGVLZXksIGZhbHNlKTtcbiAgICAgICAgLy8gTm93IHN3YXAgdGhlIGVwaGVtZXJhbCBrZXkgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IHNlbmRpbmcgY2hhaW5cbiAgICAgICAgY29uc3QgcHJldkNvdW50ZXIgPSBzZXNzaW9uLmdldENoYWluKHJhdGNoZXQuZXBoZW1lcmFsS2V5UGFpci5wdWJLZXkpO1xuICAgICAgICBpZiAocHJldkNvdW50ZXIpIHtcbiAgICAgICAgICAgIHJhdGNoZXQucHJldmlvdXNDb3VudGVyID0gcHJldkNvdW50ZXIuY2hhaW5LZXkuY291bnRlcjtcbiAgICAgICAgICAgIHNlc3Npb24uZGVsZXRlQ2hhaW4ocmF0Y2hldC5lcGhlbWVyYWxLZXlQYWlyLnB1YktleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmF0Y2hldC5lcGhlbWVyYWxLZXlQYWlyID0gY3VydmUuZ2VuZXJhdGVLZXlQYWlyKCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmF0Y2hldChzZXNzaW9uLCByZW1vdGVLZXksIHRydWUpO1xuICAgICAgICByYXRjaGV0Lmxhc3RSZW1vdGVFcGhlbWVyYWxLZXkgPSByZW1vdGVLZXk7XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlUmF0Y2hldChzZXNzaW9uLCByZW1vdGVLZXksIHNlbmRpbmcpIHtcbiAgICAgICAgbGV0IHJhdGNoZXQgPSBzZXNzaW9uLmN1cnJlbnRSYXRjaGV0O1xuICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSBjdXJ2ZS5jYWxjdWxhdGVBZ3JlZW1lbnQocmVtb3RlS2V5LCByYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHJpdktleSk7XG4gICAgICAgIGNvbnN0IG1hc3RlcktleSA9IGNyeXB0by5kZXJpdmVTZWNyZXRzKHNoYXJlZFNlY3JldCwgcmF0Y2hldC5yb290S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShcIldoaXNwZXJSYXRjaGV0XCIpLCAvKmNodW5rcyovIDIpO1xuICAgICAgICBjb25zdCBjaGFpbktleSA9IHNlbmRpbmcgPyByYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHViS2V5IDogcmVtb3RlS2V5O1xuICAgICAgICBzZXNzaW9uLmFkZENoYWluKGNoYWluS2V5LCB7XG4gICAgICAgICAgICBtZXNzYWdlS2V5czoge30sXG4gICAgICAgICAgICBjaGFpbktleToge1xuICAgICAgICAgICAgICAgIGNvdW50ZXI6IC0xLFxuICAgICAgICAgICAgICAgIGtleTogbWFzdGVyS2V5WzFdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhaW5UeXBlOiBzZW5kaW5nID8gQ2hhaW5UeXBlLlNFTkRJTkcgOiBDaGFpblR5cGUuUkVDRUlWSU5HXG4gICAgICAgIH0pO1xuICAgICAgICByYXRjaGV0LnJvb3RLZXkgPSBtYXN0ZXJLZXlbMF07XG4gICAgfVxuXG4gICAgYXN5bmMgaGFzT3BlblNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXVlSm9iKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IHRoaXMuZ2V0UmVjb3JkKCk7XG4gICAgICAgICAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQuaGF2ZU9wZW5TZXNzaW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGNsb3NlT3BlblNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXVlSm9iKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IHRoaXMuZ2V0UmVjb3JkKCk7XG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlblNlc3Npb24gPSByZWNvcmQuZ2V0T3BlblNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlblNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmNsb3NlU2Vzc2lvbihvcGVuU2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcmVSZWNvcmQocmVjb3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXNzaW9uQ2lwaGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/session_cipher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/libsignal/src/session_record.js":
/*!******************************************************!*\
  !*** ./node_modules/libsignal/src/session_record.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// vim: ts=4:sw=4\n\nconst BaseKeyType = __webpack_require__(/*! ./base_key_type */ \"(rsc)/./node_modules/libsignal/src/base_key_type.js\");\n\nconst CLOSED_SESSIONS_MAX = 40;\nconst SESSION_RECORD_VERSION = 'v1';\n\nfunction assertBuffer(value) {\n    if (!Buffer.isBuffer(value)) {\n        throw new TypeError(\"Buffer required\");\n    }\n}\n\n\nclass SessionEntry {\n\n    constructor() {\n        this._chains = {};\n    }\n\n    toString() {\n        const baseKey = this.indexInfo && this.indexInfo.baseKey &&\n            this.indexInfo.baseKey.toString('base64');\n        return `<SessionEntry [baseKey=${baseKey}]>`;\n    }\n\n    inspect() {\n        return this.toString();\n    }\n\n    addChain(key, value) {\n        assertBuffer(key);\n        const id = key.toString('base64');\n        if (this._chains.hasOwnProperty(id)) {\n            throw new Error(\"Overwrite attempt\");\n        }\n        this._chains[id] = value;\n    }\n\n    getChain(key) {\n        assertBuffer(key);\n        return this._chains[key.toString('base64')];\n    }\n\n    deleteChain(key) {\n        assertBuffer(key);\n        const id = key.toString('base64');\n        if (!this._chains.hasOwnProperty(id)) {\n            throw new ReferenceError(\"Not Found\");\n        }\n        delete this._chains[id];\n    }\n\n    *chains() {\n        for (const [k, v] of Object.entries(this._chains)) {\n            yield [Buffer.from(k, 'base64'), v];\n        }\n    }\n\n    serialize() {\n        const data = {\n            registrationId: this.registrationId,\n            currentRatchet: {\n                ephemeralKeyPair: {\n                    pubKey: this.currentRatchet.ephemeralKeyPair.pubKey.toString('base64'),\n                    privKey: this.currentRatchet.ephemeralKeyPair.privKey.toString('base64')\n                },\n                lastRemoteEphemeralKey: this.currentRatchet.lastRemoteEphemeralKey.toString('base64'),\n                previousCounter: this.currentRatchet.previousCounter,\n                rootKey: this.currentRatchet.rootKey.toString('base64')\n            },\n            indexInfo: {\n                baseKey: this.indexInfo.baseKey.toString('base64'),\n                baseKeyType: this.indexInfo.baseKeyType,\n                closed: this.indexInfo.closed,\n                used: this.indexInfo.used,\n                created: this.indexInfo.created,\n                remoteIdentityKey: this.indexInfo.remoteIdentityKey.toString('base64')\n            },\n            _chains: this._serialize_chains(this._chains)\n        };\n        if (this.pendingPreKey) {\n            data.pendingPreKey = Object.assign({}, this.pendingPreKey);\n            data.pendingPreKey.baseKey = this.pendingPreKey.baseKey.toString('base64');\n        }\n        return data;\n    }\n\n    static deserialize(data) {\n        const obj = new this();\n        obj.registrationId = data.registrationId;\n        obj.currentRatchet = {\n            ephemeralKeyPair: {\n                pubKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.pubKey, 'base64'),\n                privKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.privKey, 'base64')\n            },\n            lastRemoteEphemeralKey: Buffer.from(data.currentRatchet.lastRemoteEphemeralKey, 'base64'),\n            previousCounter: data.currentRatchet.previousCounter,\n            rootKey: Buffer.from(data.currentRatchet.rootKey, 'base64')\n        };\n        obj.indexInfo = {\n            baseKey: Buffer.from(data.indexInfo.baseKey, 'base64'),\n            baseKeyType: data.indexInfo.baseKeyType,\n            closed: data.indexInfo.closed,\n            used: data.indexInfo.used,\n            created: data.indexInfo.created,\n            remoteIdentityKey: Buffer.from(data.indexInfo.remoteIdentityKey, 'base64')\n        };\n        obj._chains = this._deserialize_chains(data._chains);\n        if (data.pendingPreKey) {\n            obj.pendingPreKey = Object.assign({}, data.pendingPreKey);\n            obj.pendingPreKey.baseKey = Buffer.from(data.pendingPreKey.baseKey, 'base64');\n        }\n        return obj;\n    }\n\n    _serialize_chains(chains) {\n        const r = {};\n        for (const key of Object.keys(chains)) {\n            const c = chains[key];\n            const messageKeys = {};\n            for (const [idx, key] of Object.entries(c.messageKeys)) {\n                messageKeys[idx] = key.toString('base64');\n            }\n            r[key] = {\n                chainKey: {\n                    counter: c.chainKey.counter,\n                    key: c.chainKey.key && c.chainKey.key.toString('base64')\n                },\n                chainType: c.chainType,\n                messageKeys: messageKeys\n            };\n        }\n        return r;\n    }\n\n    static _deserialize_chains(chains_data) {\n        const r = {};\n        for (const key of Object.keys(chains_data)) {\n            const c = chains_data[key];\n            const messageKeys = {};\n            for (const [idx, key] of Object.entries(c.messageKeys)) {\n                messageKeys[idx] = Buffer.from(key, 'base64');\n            }\n            r[key] = {\n                chainKey: {\n                    counter: c.chainKey.counter,\n                    key: c.chainKey.key && Buffer.from(c.chainKey.key, 'base64')\n                },\n                chainType: c.chainType,\n                messageKeys: messageKeys\n            };\n        }\n        return r;\n    }\n\n}\n\n\nconst migrations = [{\n    version: 'v1',\n    migrate: function migrateV1(data) {\n        const sessions = data._sessions;\n        if (data.registrationId) {\n            for (const key in sessions) {\n                if (!sessions[key].registrationId) {\n                    sessions[key].registrationId = data.registrationId;\n                }\n            }\n        } else {\n            for (const key in sessions) {\n                if (sessions[key].indexInfo.closed === -1) {\n                    console.error('V1 session storage migration error: registrationId',\n                                  data.registrationId, 'for open session version',\n                                  data.version);\n                }\n            }\n        }\n    }\n}];\n\n\nclass SessionRecord {\n\n    static createEntry() {\n        return new SessionEntry();\n    }\n\n    static migrate(data) {\n        let run = (data.version === undefined);\n        for (let i = 0; i < migrations.length; ++i) {\n            if (run) {\n                console.info(\"Migrating session to:\", migrations[i].version);\n                migrations[i].migrate(data);\n            } else if (migrations[i].version === data.version) {\n                run = true;\n            }\n        }\n        if (!run) {\n            throw new Error(\"Error migrating SessionRecord\");\n        }\n    }\n\n    static deserialize(data) {\n        if (data.version !== SESSION_RECORD_VERSION) {\n            this.migrate(data);\n        }\n        const obj = new this();\n        if (data._sessions) {\n            for (const [key, entry] of Object.entries(data._sessions)) {\n                obj.sessions[key] = SessionEntry.deserialize(entry);\n            }\n        }\n        return obj;\n    }\n\n    constructor() {\n        this.sessions = {};\n        this.version = SESSION_RECORD_VERSION;\n    }\n\n    serialize() {\n        const _sessions = {};\n        for (const [key, entry] of Object.entries(this.sessions)) {\n            _sessions[key] = entry.serialize();\n        }\n        return {\n            _sessions,\n            version: this.version\n        };\n    }\n\n    haveOpenSession() {\n        const openSession = this.getOpenSession();\n        return (!!openSession && typeof openSession.registrationId === 'number');\n    }\n\n    getSession(key) {\n        assertBuffer(key);\n        const session = this.sessions[key.toString('base64')];\n        if (session && session.indexInfo.baseKeyType === BaseKeyType.OURS) {\n            throw new Error(\"Tried to lookup a session using our basekey\");\n        }\n        return session;\n    }\n\n    getOpenSession() {\n        for (const session of Object.values(this.sessions)) {\n            if (!this.isClosed(session)) {\n                return session;\n            }\n        }\n    }\n\n    setSession(session) {\n        this.sessions[session.indexInfo.baseKey.toString('base64')] = session;\n    }\n\n    getSessions() {\n        // Return sessions ordered with most recently used first.\n        return Array.from(Object.values(this.sessions)).sort((a, b) => {\n            const aUsed = a.indexInfo.used || 0;\n            const bUsed = b.indexInfo.used || 0;\n            return aUsed === bUsed ? 0 : aUsed < bUsed ? 1 : -1;\n        });\n    }\n\n    closeSession(session) {\n        if (this.isClosed(session)) {\n            console.warn(\"Session already closed\", session);\n            return;\n        }\n        console.info(\"Closing session:\", session);\n        session.indexInfo.closed = Date.now();\n    }\n\n    openSession(session) {\n        if (!this.isClosed(session)) {\n            console.warn(\"Session already open\");\n        }\n        console.info(\"Opening session:\", session);\n        session.indexInfo.closed = -1;\n    }\n\n    isClosed(session) {\n        return session.indexInfo.closed !== -1;\n    }\n\n    removeOldSessions() {\n        while (Object.keys(this.sessions).length > CLOSED_SESSIONS_MAX) {\n            let oldestKey;\n            let oldestSession;\n            for (const [key, session] of Object.entries(this.sessions)) {\n                if (session.indexInfo.closed !== -1 &&\n                    (!oldestSession || session.indexInfo.closed < oldestSession.indexInfo.closed)) {\n                    oldestKey = key;\n                    oldestSession = session;\n                }\n            }\n            if (oldestKey) {\n                console.info(\"Removing old closed session:\", oldestSession);\n                delete this.sessions[oldestKey];\n            } else {\n                throw new Error('Corrupt sessions object');\n            }\n        }\n    }\n\n    deleteAllSessions() {\n        for (const key of Object.keys(this.sessions)) {\n            delete this.sessions[key];\n        }\n    }\n}\n\nmodule.exports = SessionRecord;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlic2lnbmFsL3NyYy9zZXNzaW9uX3JlY29yZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBaUI7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2xpYnNpZ25hbC9zcmMvc2Vzc2lvbl9yZWNvcmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdmltOiB0cz00OnN3PTRcblxuY29uc3QgQmFzZUtleVR5cGUgPSByZXF1aXJlKCcuL2Jhc2Vfa2V5X3R5cGUnKTtcblxuY29uc3QgQ0xPU0VEX1NFU1NJT05TX01BWCA9IDQwO1xuY29uc3QgU0VTU0lPTl9SRUNPUkRfVkVSU0lPTiA9ICd2MSc7XG5cbmZ1bmN0aW9uIGFzc2VydEJ1ZmZlcih2YWx1ZSkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQnVmZmVyIHJlcXVpcmVkXCIpO1xuICAgIH1cbn1cblxuXG5jbGFzcyBTZXNzaW9uRW50cnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NoYWlucyA9IHt9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBiYXNlS2V5ID0gdGhpcy5pbmRleEluZm8gJiYgdGhpcy5pbmRleEluZm8uYmFzZUtleSAmJlxuICAgICAgICAgICAgdGhpcy5pbmRleEluZm8uYmFzZUtleS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIHJldHVybiBgPFNlc3Npb25FbnRyeSBbYmFzZUtleT0ke2Jhc2VLZXl9XT5gO1xuICAgIH1cblxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgYWRkQ2hhaW4oa2V5LCB2YWx1ZSkge1xuICAgICAgICBhc3NlcnRCdWZmZXIoa2V5KTtcbiAgICAgICAgY29uc3QgaWQgPSBrZXkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAodGhpcy5fY2hhaW5zLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcndyaXRlIGF0dGVtcHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhaW5zW2lkXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldENoYWluKGtleSkge1xuICAgICAgICBhc3NlcnRCdWZmZXIoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluc1trZXkudG9TdHJpbmcoJ2Jhc2U2NCcpXTtcbiAgICB9XG5cbiAgICBkZWxldGVDaGFpbihrZXkpIHtcbiAgICAgICAgYXNzZXJ0QnVmZmVyKGtleSk7XG4gICAgICAgIGNvbnN0IGlkID0ga2V5LnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jaGFpbnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJOb3QgRm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX2NoYWluc1tpZF07XG4gICAgfVxuXG4gICAgKmNoYWlucygpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY2hhaW5zKSkge1xuICAgICAgICAgICAgeWllbGQgW0J1ZmZlci5mcm9tKGssICdiYXNlNjQnKSwgdl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25JZDogdGhpcy5yZWdpc3RyYXRpb25JZCxcbiAgICAgICAgICAgIGN1cnJlbnRSYXRjaGV0OiB7XG4gICAgICAgICAgICAgICAgZXBoZW1lcmFsS2V5UGFpcjoge1xuICAgICAgICAgICAgICAgICAgICBwdWJLZXk6IHRoaXMuY3VycmVudFJhdGNoZXQuZXBoZW1lcmFsS2V5UGFpci5wdWJLZXkudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgICAgICAgICAgICAgICBwcml2S2V5OiB0aGlzLmN1cnJlbnRSYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHJpdktleS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVFcGhlbWVyYWxLZXk6IHRoaXMuY3VycmVudFJhdGNoZXQubGFzdFJlbW90ZUVwaGVtZXJhbEtleS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgICAgICAgcHJldmlvdXNDb3VudGVyOiB0aGlzLmN1cnJlbnRSYXRjaGV0LnByZXZpb3VzQ291bnRlcixcbiAgICAgICAgICAgICAgICByb290S2V5OiB0aGlzLmN1cnJlbnRSYXRjaGV0LnJvb3RLZXkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5kZXhJbmZvOiB7XG4gICAgICAgICAgICAgICAgYmFzZUtleTogdGhpcy5pbmRleEluZm8uYmFzZUtleS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgICAgICAgYmFzZUtleVR5cGU6IHRoaXMuaW5kZXhJbmZvLmJhc2VLZXlUeXBlLFxuICAgICAgICAgICAgICAgIGNsb3NlZDogdGhpcy5pbmRleEluZm8uY2xvc2VkLFxuICAgICAgICAgICAgICAgIHVzZWQ6IHRoaXMuaW5kZXhJbmZvLnVzZWQsXG4gICAgICAgICAgICAgICAgY3JlYXRlZDogdGhpcy5pbmRleEluZm8uY3JlYXRlZCxcbiAgICAgICAgICAgICAgICByZW1vdGVJZGVudGl0eUtleTogdGhpcy5pbmRleEluZm8ucmVtb3RlSWRlbnRpdHlLZXkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NoYWluczogdGhpcy5fc2VyaWFsaXplX2NoYWlucyh0aGlzLl9jaGFpbnMpXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdQcmVLZXkpIHtcbiAgICAgICAgICAgIGRhdGEucGVuZGluZ1ByZUtleSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGVuZGluZ1ByZUtleSk7XG4gICAgICAgICAgICBkYXRhLnBlbmRpbmdQcmVLZXkuYmFzZUtleSA9IHRoaXMucGVuZGluZ1ByZUtleS5iYXNlS2V5LnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICBjb25zdCBvYmogPSBuZXcgdGhpcygpO1xuICAgICAgICBvYmoucmVnaXN0cmF0aW9uSWQgPSBkYXRhLnJlZ2lzdHJhdGlvbklkO1xuICAgICAgICBvYmouY3VycmVudFJhdGNoZXQgPSB7XG4gICAgICAgICAgICBlcGhlbWVyYWxLZXlQYWlyOiB7XG4gICAgICAgICAgICAgICAgcHViS2V5OiBCdWZmZXIuZnJvbShkYXRhLmN1cnJlbnRSYXRjaGV0LmVwaGVtZXJhbEtleVBhaXIucHViS2V5LCAnYmFzZTY0JyksXG4gICAgICAgICAgICAgICAgcHJpdktleTogQnVmZmVyLmZyb20oZGF0YS5jdXJyZW50UmF0Y2hldC5lcGhlbWVyYWxLZXlQYWlyLnByaXZLZXksICdiYXNlNjQnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RSZW1vdGVFcGhlbWVyYWxLZXk6IEJ1ZmZlci5mcm9tKGRhdGEuY3VycmVudFJhdGNoZXQubGFzdFJlbW90ZUVwaGVtZXJhbEtleSwgJ2Jhc2U2NCcpLFxuICAgICAgICAgICAgcHJldmlvdXNDb3VudGVyOiBkYXRhLmN1cnJlbnRSYXRjaGV0LnByZXZpb3VzQ291bnRlcixcbiAgICAgICAgICAgIHJvb3RLZXk6IEJ1ZmZlci5mcm9tKGRhdGEuY3VycmVudFJhdGNoZXQucm9vdEtleSwgJ2Jhc2U2NCcpXG4gICAgICAgIH07XG4gICAgICAgIG9iai5pbmRleEluZm8gPSB7XG4gICAgICAgICAgICBiYXNlS2V5OiBCdWZmZXIuZnJvbShkYXRhLmluZGV4SW5mby5iYXNlS2V5LCAnYmFzZTY0JyksXG4gICAgICAgICAgICBiYXNlS2V5VHlwZTogZGF0YS5pbmRleEluZm8uYmFzZUtleVR5cGUsXG4gICAgICAgICAgICBjbG9zZWQ6IGRhdGEuaW5kZXhJbmZvLmNsb3NlZCxcbiAgICAgICAgICAgIHVzZWQ6IGRhdGEuaW5kZXhJbmZvLnVzZWQsXG4gICAgICAgICAgICBjcmVhdGVkOiBkYXRhLmluZGV4SW5mby5jcmVhdGVkLFxuICAgICAgICAgICAgcmVtb3RlSWRlbnRpdHlLZXk6IEJ1ZmZlci5mcm9tKGRhdGEuaW5kZXhJbmZvLnJlbW90ZUlkZW50aXR5S2V5LCAnYmFzZTY0JylcbiAgICAgICAgfTtcbiAgICAgICAgb2JqLl9jaGFpbnMgPSB0aGlzLl9kZXNlcmlhbGl6ZV9jaGFpbnMoZGF0YS5fY2hhaW5zKTtcbiAgICAgICAgaWYgKGRhdGEucGVuZGluZ1ByZUtleSkge1xuICAgICAgICAgICAgb2JqLnBlbmRpbmdQcmVLZXkgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhLnBlbmRpbmdQcmVLZXkpO1xuICAgICAgICAgICAgb2JqLnBlbmRpbmdQcmVLZXkuYmFzZUtleSA9IEJ1ZmZlci5mcm9tKGRhdGEucGVuZGluZ1ByZUtleS5iYXNlS2V5LCAnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfc2VyaWFsaXplX2NoYWlucyhjaGFpbnMpIHtcbiAgICAgICAgY29uc3QgciA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjaGFpbnMpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gY2hhaW5zW2tleV07XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlS2V5cyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWR4LCBrZXldIG9mIE9iamVjdC5lbnRyaWVzKGMubWVzc2FnZUtleXMpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUtleXNbaWR4XSA9IGtleS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgY2hhaW5LZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjogYy5jaGFpbktleS5jb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGMuY2hhaW5LZXkua2V5ICYmIGMuY2hhaW5LZXkua2V5LnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hhaW5UeXBlOiBjLmNoYWluVHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlS2V5czogbWVzc2FnZUtleXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgc3RhdGljIF9kZXNlcmlhbGl6ZV9jaGFpbnMoY2hhaW5zX2RhdGEpIHtcbiAgICAgICAgY29uc3QgciA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjaGFpbnNfZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjaGFpbnNfZGF0YVtrZXldO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUtleXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkeCwga2V5XSBvZiBPYmplY3QuZW50cmllcyhjLm1lc3NhZ2VLZXlzKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VLZXlzW2lkeF0gPSBCdWZmZXIuZnJvbShrZXksICdiYXNlNjQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBjaGFpbktleToge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyOiBjLmNoYWluS2V5LmNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogYy5jaGFpbktleS5rZXkgJiYgQnVmZmVyLmZyb20oYy5jaGFpbktleS5rZXksICdiYXNlNjQnKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hhaW5UeXBlOiBjLmNoYWluVHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlS2V5czogbWVzc2FnZUtleXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG59XG5cblxuY29uc3QgbWlncmF0aW9ucyA9IFt7XG4gICAgdmVyc2lvbjogJ3YxJyxcbiAgICBtaWdyYXRlOiBmdW5jdGlvbiBtaWdyYXRlVjEoZGF0YSkge1xuICAgICAgICBjb25zdCBzZXNzaW9ucyA9IGRhdGEuX3Nlc3Npb25zO1xuICAgICAgICBpZiAoZGF0YS5yZWdpc3RyYXRpb25JZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2Vzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25zW2tleV0ucmVnaXN0cmF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbnNba2V5XS5yZWdpc3RyYXRpb25JZCA9IGRhdGEucmVnaXN0cmF0aW9uSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2Vzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbnNba2V5XS5pbmRleEluZm8uY2xvc2VkID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdWMSBzZXNzaW9uIHN0b3JhZ2UgbWlncmF0aW9uIGVycm9yOiByZWdpc3RyYXRpb25JZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yZWdpc3RyYXRpb25JZCwgJ2ZvciBvcGVuIHNlc3Npb24gdmVyc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS52ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XTtcblxuXG5jbGFzcyBTZXNzaW9uUmVjb3JkIHtcblxuICAgIHN0YXRpYyBjcmVhdGVFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXNzaW9uRW50cnkoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWlncmF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBydW4gPSAoZGF0YS52ZXJzaW9uID09PSB1bmRlZmluZWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pZ3JhdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChydW4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJNaWdyYXRpbmcgc2Vzc2lvbiB0bzpcIiwgbWlncmF0aW9uc1tpXS52ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBtaWdyYXRpb25zW2ldLm1pZ3JhdGUoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pZ3JhdGlvbnNbaV0udmVyc2lvbiA9PT0gZGF0YS52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgcnVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgbWlncmF0aW5nIFNlc3Npb25SZWNvcmRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS52ZXJzaW9uICE9PSBTRVNTSU9OX1JFQ09SRF9WRVJTSU9OKSB7XG4gICAgICAgICAgICB0aGlzLm1pZ3JhdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqID0gbmV3IHRoaXMoKTtcbiAgICAgICAgaWYgKGRhdGEuX3Nlc3Npb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyhkYXRhLl9zZXNzaW9ucykpIHtcbiAgICAgICAgICAgICAgICBvYmouc2Vzc2lvbnNba2V5XSA9IFNlc3Npb25FbnRyeS5kZXNlcmlhbGl6ZShlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBTRVNTSU9OX1JFQ09SRF9WRVJTSU9OO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgX3Nlc3Npb25zID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuc2Vzc2lvbnMpKSB7XG4gICAgICAgICAgICBfc2Vzc2lvbnNba2V5XSA9IGVudHJ5LnNlcmlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfc2Vzc2lvbnMsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBoYXZlT3BlblNlc3Npb24oKSB7XG4gICAgICAgIGNvbnN0IG9wZW5TZXNzaW9uID0gdGhpcy5nZXRPcGVuU2Vzc2lvbigpO1xuICAgICAgICByZXR1cm4gKCEhb3BlblNlc3Npb24gJiYgdHlwZW9mIG9wZW5TZXNzaW9uLnJlZ2lzdHJhdGlvbklkID09PSAnbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgZ2V0U2Vzc2lvbihrZXkpIHtcbiAgICAgICAgYXNzZXJ0QnVmZmVyKGtleSk7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb25zW2tleS50b1N0cmluZygnYmFzZTY0JyldO1xuICAgICAgICBpZiAoc2Vzc2lvbiAmJiBzZXNzaW9uLmluZGV4SW5mby5iYXNlS2V5VHlwZSA9PT0gQmFzZUtleVR5cGUuT1VSUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gbG9va3VwIGEgc2Vzc2lvbiB1c2luZyBvdXIgYmFzZWtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9XG5cbiAgICBnZXRPcGVuU2Vzc2lvbigpIHtcbiAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIE9iamVjdC52YWx1ZXModGhpcy5zZXNzaW9ucykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZChzZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0U2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbnNbc2Vzc2lvbi5pbmRleEluZm8uYmFzZUtleS50b1N0cmluZygnYmFzZTY0JyldID0gc2Vzc2lvbjtcbiAgICB9XG5cbiAgICBnZXRTZXNzaW9ucygpIHtcbiAgICAgICAgLy8gUmV0dXJuIHNlc3Npb25zIG9yZGVyZWQgd2l0aCBtb3N0IHJlY2VudGx5IHVzZWQgZmlyc3QuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXModGhpcy5zZXNzaW9ucykpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFVc2VkID0gYS5pbmRleEluZm8udXNlZCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgYlVzZWQgPSBiLmluZGV4SW5mby51c2VkIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gYVVzZWQgPT09IGJVc2VkID8gMCA6IGFVc2VkIDwgYlVzZWQgPyAxIDogLTE7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsb3NlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKHNlc3Npb24pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTZXNzaW9uIGFscmVhZHkgY2xvc2VkXCIsIHNlc3Npb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkNsb3Npbmcgc2Vzc2lvbjpcIiwgc2Vzc2lvbik7XG4gICAgICAgIHNlc3Npb24uaW5kZXhJbmZvLmNsb3NlZCA9IERhdGUubm93KCk7XG4gICAgfVxuXG4gICAgb3BlblNlc3Npb24oc2Vzc2lvbikge1xuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWQoc2Vzc2lvbikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNlc3Npb24gYWxyZWFkeSBvcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIk9wZW5pbmcgc2Vzc2lvbjpcIiwgc2Vzc2lvbik7XG4gICAgICAgIHNlc3Npb24uaW5kZXhJbmZvLmNsb3NlZCA9IC0xO1xuICAgIH1cblxuICAgIGlzQ2xvc2VkKHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb24uaW5kZXhJbmZvLmNsb3NlZCAhPT0gLTE7XG4gICAgfVxuXG4gICAgcmVtb3ZlT2xkU2Vzc2lvbnMoKSB7XG4gICAgICAgIHdoaWxlIChPYmplY3Qua2V5cyh0aGlzLnNlc3Npb25zKS5sZW5ndGggPiBDTE9TRURfU0VTU0lPTlNfTUFYKSB7XG4gICAgICAgICAgICBsZXQgb2xkZXN0S2V5O1xuICAgICAgICAgICAgbGV0IG9sZGVzdFNlc3Npb247XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHNlc3Npb25dIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuc2Vzc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uaW5kZXhJbmZvLmNsb3NlZCAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFvbGRlc3RTZXNzaW9uIHx8IHNlc3Npb24uaW5kZXhJbmZvLmNsb3NlZCA8IG9sZGVzdFNlc3Npb24uaW5kZXhJbmZvLmNsb3NlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkZXN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICBvbGRlc3RTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkZXN0S2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiUmVtb3Zpbmcgb2xkIGNsb3NlZCBzZXNzaW9uOlwiLCBvbGRlc3RTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZXNzaW9uc1tvbGRlc3RLZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvcnJ1cHQgc2Vzc2lvbnMgb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGVBbGxTZXNzaW9ucygpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5zZXNzaW9ucykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlc3Npb25zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2Vzc2lvblJlY29yZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libsignal/src/session_record.js\n");

/***/ })

};
;