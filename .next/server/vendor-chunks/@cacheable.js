"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@cacheable";
exports.ids = ["vendor-chunks/@cacheable"];
exports.modules = {

/***/ "(rsc)/./node_modules/@cacheable/node-cache/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@cacheable/node-cache/dist/index.cjs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  NodeCache: () => NodeCache,\n  NodeCacheErrors: () => NodeCacheErrors,\n  NodeCacheStore: () => NodeCacheStore,\n  default: () => index_default\n});\nmodule.exports = __toCommonJS(index_exports);\nvar import_cacheable2 = __webpack_require__(/*! cacheable */ \"(rsc)/./node_modules/cacheable/dist/index.cjs\");\nvar import_hookified2 = __webpack_require__(/*! hookified */ \"(rsc)/./node_modules/hookified/dist/node/index.cjs\");\n\n// src/store.ts\nvar import_cacheable = __webpack_require__(/*! cacheable */ \"(rsc)/./node_modules/cacheable/dist/index.cjs\");\nvar import_hookified = __webpack_require__(/*! hookified */ \"(rsc)/./node_modules/hookified/dist/node/index.cjs\");\nvar import_keyv = __webpack_require__(/*! keyv */ \"keyv\");\nvar NodeCacheStore = class extends import_hookified.Hookified {\n  _maxKeys = 0;\n  _cache = new import_cacheable.Cacheable({\n    primary: new import_keyv.Keyv({ store: new import_cacheable.CacheableMemory() })\n  });\n  constructor(options) {\n    super();\n    if (options) {\n      const cacheOptions = {\n        ttl: options.ttl,\n        primary: options.primary,\n        secondary: options.secondary,\n        stats: options.stats ?? true\n      };\n      this._cache = new import_cacheable.Cacheable(cacheOptions);\n      if (options.maxKeys) {\n        this._maxKeys = options.maxKeys;\n      }\n    }\n    this._cache.on(\"error\", (error) => {\n      this.emit(\"error\", error);\n    });\n  }\n  /**\n   * Cacheable instance.\n   * @returns {Cacheable}\n   * @readonly\n   */\n  get cache() {\n    return this._cache;\n  }\n  /**\n   * Time to live in milliseconds.\n   * @returns {number | string | undefined}\n   * @readonly\n   */\n  get ttl() {\n    return this._cache.ttl;\n  }\n  /**\n   * Time to live in milliseconds.\n   * @param {number | string | undefined} ttl\n   */\n  set ttl(ttl) {\n    this._cache.ttl = ttl;\n  }\n  /**\n   * Primary cache store.\n   * @returns {Keyv<T>}\n   * @readonly\n   */\n  get primary() {\n    return this._cache.primary;\n  }\n  /**\n   * Primary cache store.\n   * @param {Keyv<T>} primary\n   */\n  set primary(primary) {\n    this._cache.primary = primary;\n  }\n  /**\n   * Secondary cache store. Learn more about the secondary cache store in the\n   * [cacheable](https://github.com/jaredwray/cacheable/tree/main/packages/cacheable#storage-tiering-and-caching) documentation.\n   * @returns {Keyv<T> | undefined}\n   */\n  get secondary() {\n    return this._cache.secondary;\n  }\n  /**\n   * Secondary cache store. Learn more about the secondary cache store in the\n   * [cacheable](https://github.com/jaredwray/cacheable/tree/main/packages/cacheable#storage-tiering-and-caching) documentation.\n   * @param {Keyv | undefined} secondary\n   */\n  set secondary(secondary) {\n    this._cache.secondary = secondary;\n  }\n  /**\n   * Maximum number of keys to store in the cache. if this is set to a value greater than 0,\n   * the cache will keep track of the number of keys and will not store more than the specified number of keys.\n   * @returns {number}\n   * @readonly\n   */\n  get maxKeys() {\n    return this._maxKeys;\n  }\n  /**\n   * Maximum number of keys to store in the cache. if this is set to a value greater than 0,\n   * the cache will keep track of the number of keys and will not store more than the specified number of keys.\n   * @param {number} maxKeys\n   */\n  set maxKeys(maxKeys) {\n    this._maxKeys = maxKeys;\n    if (this._maxKeys > 0) {\n      this._cache.stats.enabled = true;\n    }\n  }\n  /**\n   * Set a key/value pair in the cache.\n   * @param {string | number} key\n   * @param {T} value\n   * @param {number} [ttl]\n   * @returns {boolean}\n   */\n  async set(key, value, ttl) {\n    if (this._maxKeys > 0) {\n      if (this._cache.stats.count >= this._maxKeys) {\n        return false;\n      }\n    }\n    await this._cache.set(key.toString(), value, ttl);\n    return true;\n  }\n  /**\n   * Set multiple key/value pairs in the cache.\n   * @param {PartialNodeCacheItem[]} list\n   * @returns {void}\n   */\n  async mset(list) {\n    const items = [];\n    for (const item of list) {\n      items.push({\n        key: item.key.toString(),\n        value: item.value,\n        ttl: item.ttl\n      });\n    }\n    await this._cache.setMany(items);\n  }\n  /**\n   * Get a value from the cache.\n   * @param {string | number} key\n   * @returns {any | undefined}\n   */\n  async get(key) {\n    return this._cache.get(key.toString());\n  }\n  /**\n   * Get multiple values from the cache.\n   * @param {Array<string | number>} keys\n   * @returns {Record<string, any | undefined>}\n   */\n  async mget(keys) {\n    const result = {};\n    for (const key of keys) {\n      result[key.toString()] = await this._cache.get(key.toString());\n    }\n    return result;\n  }\n  /**\n   * Delete a key from the cache.\n   * @param {string | number} key\n   * @returns {boolean}\n   */\n  async del(key) {\n    return this._cache.delete(key.toString());\n  }\n  /**\n   * Delete multiple keys from the cache.\n   * @param {Array<string | number>} keys\n   * @returns {boolean}\n   */\n  async mdel(keys) {\n    return this._cache.deleteMany(keys.map((key) => key.toString()));\n  }\n  /**\n   * Clear the cache.\n   * @returns {void}\n   */\n  async clear() {\n    return this._cache.clear();\n  }\n  /**\n   * Check if a key exists in the cache.\n   * @param {string | number} key\n   * @returns {boolean}\n   */\n  async setTtl(key, ttl) {\n    const item = await this._cache.get(key.toString());\n    if (item) {\n      await this._cache.set(key.toString(), item, ttl);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Check if a key exists in the cache. If it does exist it will get the value and delete the item from the cache.\n   * @param {string | number} key\n   * @returns {T | undefined}\n   */\n  async take(key) {\n    return this._cache.take(key.toString());\n  }\n  /**\n   * Disconnect from the cache.\n   * @returns {void}\n   */\n  async disconnect() {\n    await this._cache.disconnect();\n  }\n};\n\n// src/index.ts\nvar NodeCacheErrors = /* @__PURE__ */ ((NodeCacheErrors2) => {\n  NodeCacheErrors2[\"ECACHEFULL\"] = \"Cache max keys amount exceeded\";\n  NodeCacheErrors2[\"EKEYTYPE\"] = \"The key argument has to be of type `string` or `number`. Found: `__key`\";\n  NodeCacheErrors2[\"EKEYSTYPE\"] = \"The keys argument has to be an array.\";\n  NodeCacheErrors2[\"ETTLTYPE\"] = \"The ttl argument has to be a number or a string for shorthand ttl.\";\n  return NodeCacheErrors2;\n})(NodeCacheErrors || {});\nvar NodeCache = class extends import_hookified2.Hookified {\n  options = {\n    stdTTL: 0,\n    checkperiod: 600,\n    useClones: true,\n    deleteOnExpire: true,\n    maxKeys: -1\n  };\n  store = /* @__PURE__ */ new Map();\n  _stats = new import_cacheable2.CacheableStats({ enabled: true });\n  _cacheable = new import_cacheable2.CacheableMemory();\n  intervalId = 0;\n  constructor(options) {\n    super();\n    if (options) {\n      this.options = { ...this.options, ...options };\n    }\n    this.startInterval();\n  }\n  /**\n   * Sets a key value pair. It is possible to define a ttl (in seconds). Returns true on success.\n   * @param {string | number} key - it will convert the key to a string\n   * @param {T} value\n   * @param {number | string} [ttl] - this is in seconds and undefined will use the default ttl\n   * @returns {boolean}\n   */\n  set(key, value, ttl = 0) {\n    if (typeof key !== \"string\" && typeof key !== \"number\") {\n      throw this.createError(\"The key argument has to be of type `string` or `number`. Found: `__key`\" /* EKEYTYPE */, key);\n    }\n    if (ttl && typeof ttl !== \"number\" && typeof ttl !== \"string\") {\n      throw this.createError(\"The ttl argument has to be a number or a string for shorthand ttl.\" /* ETTLTYPE */, this.formatKey(key));\n    }\n    const keyValue = this.formatKey(key);\n    let ttlValue = 0;\n    if (this.options.stdTTL) {\n      ttlValue = this.getExpirationTimestamp(this.options.stdTTL);\n    }\n    if (ttl) {\n      ttlValue = this.getExpirationTimestamp(ttl);\n    }\n    let expirationTimestamp = 0;\n    if (ttlValue && ttlValue > 0) {\n      expirationTimestamp = ttlValue;\n    }\n    if (this.options.maxKeys) {\n      const { maxKeys } = this.options;\n      if (maxKeys > -1 && this.store.size >= maxKeys) {\n        throw this.createError(\"Cache max keys amount exceeded\" /* ECACHEFULL */, this.formatKey(key));\n      }\n    }\n    this.store.set(keyValue, {\n      key: keyValue,\n      value,\n      ttl: expirationTimestamp\n    });\n    this.emit(\"set\", keyValue, value, ttlValue);\n    this._stats.incrementKSize(keyValue);\n    this._stats.incrementVSize(value);\n    this._stats.setCount(this.store.size);\n    return true;\n  }\n  /**\n   * Sets multiple key val pairs. It is possible to define a ttl (seconds). Returns true on success.\n   * @param {PartialNodeCacheItem<T>[]} data an array of key value pairs with optional ttl\n   * @returns {boolean}\n   */\n  mset(data) {\n    if (!Array.isArray(data)) {\n      throw this.createError(\"The keys argument has to be an array.\" /* EKEYSTYPE */);\n    }\n    for (const item of data) {\n      this.set(item.key, item.value, item.ttl);\n    }\n    return true;\n  }\n  /**\n   * Gets a saved value from the cache. Returns a undefined if not found or expired. If the value was found it returns the value.\n   * @param {string | number} key if the key is a number it will convert it to a string\n   * @returns {T} the value or undefined\n   */\n  get(key) {\n    const result = this.store.get(this.formatKey(key));\n    if (result) {\n      if (result.ttl > 0) {\n        if (result.ttl < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            this.del(key);\n          }\n          this._stats.incrementMisses();\n          this.emit(\"expired\", this.formatKey(key), result.value);\n          return void 0;\n        }\n        this._stats.incrementHits();\n        if (this.options.useClones) {\n          return this._cacheable.clone(result.value);\n        }\n        return result.value;\n      }\n      this._stats.incrementHits();\n      if (this.options.useClones) {\n        return this._cacheable.clone(result.value);\n      }\n      return result.value;\n    }\n    this._stats.incrementMisses();\n    return void 0;\n  }\n  /**\n   * Gets multiple saved values from the cache. Returns an empty object {} if not found or expired.\n   * If the value was found it returns an object with the key value pair.\n   * @param {Array<string | number} keys an array of keys\n   * @returns {Record<string, T | undefined>} an object with the key as a property and the value as the value\n   */\n  mget(keys) {\n    const result = {};\n    for (const key of keys) {\n      const value = this.get(key);\n      if (value) {\n        result[this.formatKey(key)] = value;\n      }\n    }\n    return result;\n  }\n  /**\n   * Get the cached value and remove the key from the cache. Equivalent to calling get(key) + del(key).\n   * Useful for implementing single use mechanism such as OTP, where once a value is read it will become obsolete.\n   * @param {string | number} key\n   * @returns {T | undefined} the value or undefined\n   */\n  take(key) {\n    const result = this.get(key);\n    if (result) {\n      this.del(key);\n      if (this.options.useClones) {\n        return this._cacheable.clone(result);\n      }\n      return result;\n    }\n    return void 0;\n  }\n  /**\n   * Delete a key. Returns the number of deleted entries. A delete will never fail.\n   * @param {string | number | Array<string | number>} key if the key is a number it will convert it to a string. if an array is passed it will delete all keys in the array.\n   * @returns {number} if it was successful it will return the count that was deleted\n   */\n  del(key) {\n    if (Array.isArray(key)) {\n      return this.mdel(key);\n    }\n    const result = this.store.get(this.formatKey(key));\n    if (result) {\n      const keyValue = this.formatKey(key);\n      this.store.delete(keyValue);\n      this.emit(\"del\", keyValue, result.value);\n      this._stats.decreaseKSize(keyValue);\n      this._stats.decreaseVSize(result.value);\n      this._stats.setCount(this.store.size);\n      return 1;\n    }\n    return 0;\n  }\n  /**\n   * Delete all keys in Array that exist. Returns the number of deleted entries.\n   * @param {Array<string | number>} keys an array of keys\n   * @returns {number} the count of deleted keys\n   */\n  mdel(keys) {\n    let result = 0;\n    for (const key of keys) {\n      result += this.del(key);\n    }\n    return result;\n  }\n  /**\n   * Redefine the ttl of a key. Returns true if the key has been found and changed.\n   * Otherwise returns false. If the ttl-argument isn't passed the default-TTL will be used.\n   * @param {string | number} key if the key is a number it will convert it to a string\n   * @param {number | string} [ttl] the ttl in seconds if number, or a shorthand string like '1h' for 1 hour\n   * @returns {boolean} true if the key has been found and changed. Otherwise returns false.\n   */\n  ttl(key, ttl) {\n    const result = this.store.get(this.formatKey(key));\n    if (result) {\n      const ttlValue = ttl ?? this.options.stdTTL;\n      result.ttl = this.getExpirationTimestamp(ttlValue);\n      this.store.set(this.formatKey(key), result);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Receive the ttl of a key.\n   * @param {string | number} key if the key is a number it will convert it to a string\n   * @returns {number | undefined} 0 if this key has no ttl, undefined if this key is not in the cache,\n   * a timestamp in ms representing the time at which this key will expire\n   */\n  getTtl(key) {\n    const result = this.store.get(this.formatKey(key));\n    if (result) {\n      if (result.ttl === 0) {\n        return 0;\n      }\n      return result.ttl;\n    }\n    return void 0;\n  }\n  /**\n   * Returns an array of all existing keys. [ \"all\", \"my\", \"keys\", \"foo\", \"bar\" ]\n   * @returns {string[]} an array of all keys\n   */\n  keys() {\n    const result = [];\n    for (const key of this.store.keys()) {\n      result.push(key);\n    }\n    return result;\n  }\n  /**\n   * Returns boolean indicating if the key is cached.\n   * @param {string | number} key if the key is a number it will convert it to a string\n   * @returns {boolean} true if the key is cached\n   */\n  has(key) {\n    return this.store.has(this.formatKey(key));\n  }\n  /**\n   * Gets the stats of the cache\n   * @returns {NodeCacheStats} the stats of the cache\n   */\n  getStats() {\n    const stats = {\n      keys: this._stats.count,\n      hits: this._stats.hits,\n      misses: this._stats.misses,\n      ksize: this._stats.ksize,\n      vsize: this._stats.vsize\n    };\n    return stats;\n  }\n  /**\n   * Flush the whole data.\n   * @returns {void}\n   */\n  flushAll() {\n    this.store.clear();\n    this.flushStats();\n    this.emit(\"flush\");\n  }\n  /**\n   * Flush the stats.\n   * @returns {void}\n   */\n  flushStats() {\n    this._stats = new import_cacheable2.CacheableStats({ enabled: true });\n    this.emit(\"flush_stats\");\n  }\n  /**\n   * Close the cache. This will clear the interval timeout which is set on check period option.\n   * @returns {void}\n   */\n  close() {\n    this.stopInterval();\n  }\n  /**\n   * Get the interval id\n   * @returns {number | NodeJS.Timeout} the interval id\n   */\n  getIntervalId() {\n    return this.intervalId;\n  }\n  formatKey(key) {\n    return key.toString();\n  }\n  getExpirationTimestamp(ttlInSeconds) {\n    if (typeof ttlInSeconds === \"string\") {\n      return (0, import_cacheable2.shorthandToTime)(ttlInSeconds);\n    }\n    const currentTimestamp = Date.now();\n    const ttlInMilliseconds = ttlInSeconds * 1e3;\n    const expirationTimestamp = currentTimestamp + ttlInMilliseconds;\n    return expirationTimestamp;\n  }\n  startInterval() {\n    if (this.options.checkperiod && this.options.checkperiod > 0) {\n      const checkPeriodinSeconds = this.options.checkperiod * 1e3;\n      this.intervalId = setInterval(() => {\n        this.checkData();\n      }, checkPeriodinSeconds).unref();\n      return;\n    }\n    this.intervalId = 0;\n  }\n  checkData() {\n    for (const [key, value] of this.store.entries()) {\n      if (value.ttl > 0 && value.ttl < Date.now()) {\n        if (this.options.deleteOnExpire) {\n          this.del(key);\n        }\n        this.emit(\"expired\", this.formatKey(key), value.value);\n      }\n    }\n  }\n  stopInterval() {\n    if (this.intervalId !== 0) {\n      clearInterval(this.intervalId);\n      this.intervalId = 0;\n    }\n  }\n  createError(errorCode, key) {\n    let error = errorCode;\n    if (key) {\n      error = error.replace(\"__key\", key);\n    }\n    return new Error(error);\n  }\n};\nvar index_default = NodeCache;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNhY2hlYWJsZS9ub2RlLWNhY2hlL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsZ0VBQVc7QUFDM0Msd0JBQXdCLG1CQUFPLENBQUMscUVBQVc7O0FBRTNDO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsZ0VBQVc7QUFDMUMsdUJBQXVCLG1CQUFPLENBQUMscUVBQVc7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsa0JBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUErQztBQUNuRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNB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LE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBSUwiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BjYWNoZWFibGUvbm9kZS1jYWNoZS9kaXN0L2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGluZGV4X2V4cG9ydHMsIHtcbiAgTm9kZUNhY2hlOiAoKSA9PiBOb2RlQ2FjaGUsXG4gIE5vZGVDYWNoZUVycm9yczogKCkgPT4gTm9kZUNhY2hlRXJyb3JzLFxuICBOb2RlQ2FjaGVTdG9yZTogKCkgPT4gTm9kZUNhY2hlU3RvcmUsXG4gIGRlZmF1bHQ6ICgpID0+IGluZGV4X2RlZmF1bHRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoaW5kZXhfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2NhY2hlYWJsZTIgPSByZXF1aXJlKFwiY2FjaGVhYmxlXCIpO1xudmFyIGltcG9ydF9ob29raWZpZWQyID0gcmVxdWlyZShcImhvb2tpZmllZFwiKTtcblxuLy8gc3JjL3N0b3JlLnRzXG52YXIgaW1wb3J0X2NhY2hlYWJsZSA9IHJlcXVpcmUoXCJjYWNoZWFibGVcIik7XG52YXIgaW1wb3J0X2hvb2tpZmllZCA9IHJlcXVpcmUoXCJob29raWZpZWRcIik7XG52YXIgaW1wb3J0X2tleXYgPSByZXF1aXJlKFwia2V5dlwiKTtcbnZhciBOb2RlQ2FjaGVTdG9yZSA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X2hvb2tpZmllZC5Ib29raWZpZWQge1xuICBfbWF4S2V5cyA9IDA7XG4gIF9jYWNoZSA9IG5ldyBpbXBvcnRfY2FjaGVhYmxlLkNhY2hlYWJsZSh7XG4gICAgcHJpbWFyeTogbmV3IGltcG9ydF9rZXl2LktleXYoeyBzdG9yZTogbmV3IGltcG9ydF9jYWNoZWFibGUuQ2FjaGVhYmxlTWVtb3J5KCkgfSlcbiAgfSk7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBjYWNoZU9wdGlvbnMgPSB7XG4gICAgICAgIHR0bDogb3B0aW9ucy50dGwsXG4gICAgICAgIHByaW1hcnk6IG9wdGlvbnMucHJpbWFyeSxcbiAgICAgICAgc2Vjb25kYXJ5OiBvcHRpb25zLnNlY29uZGFyeSxcbiAgICAgICAgc3RhdHM6IG9wdGlvbnMuc3RhdHMgPz8gdHJ1ZVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2NhY2hlID0gbmV3IGltcG9ydF9jYWNoZWFibGUuQ2FjaGVhYmxlKGNhY2hlT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5tYXhLZXlzKSB7XG4gICAgICAgIHRoaXMuX21heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhY2hlYWJsZSBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0NhY2hlYWJsZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICB9XG4gIC8qKlxuICAgKiBUaW1lIHRvIGxpdmUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgc3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB0dGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnR0bDtcbiAgfVxuICAvKipcbiAgICogVGltZSB0byBsaXZlIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmcgfCB1bmRlZmluZWR9IHR0bFxuICAgKi9cbiAgc2V0IHR0bCh0dGwpIHtcbiAgICB0aGlzLl9jYWNoZS50dGwgPSB0dGw7XG4gIH1cbiAgLyoqXG4gICAqIFByaW1hcnkgY2FjaGUgc3RvcmUuXG4gICAqIEByZXR1cm5zIHtLZXl2PFQ+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmltYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5wcmltYXJ5O1xuICB9XG4gIC8qKlxuICAgKiBQcmltYXJ5IGNhY2hlIHN0b3JlLlxuICAgKiBAcGFyYW0ge0tleXY8VD59IHByaW1hcnlcbiAgICovXG4gIHNldCBwcmltYXJ5KHByaW1hcnkpIHtcbiAgICB0aGlzLl9jYWNoZS5wcmltYXJ5ID0gcHJpbWFyeTtcbiAgfVxuICAvKipcbiAgICogU2Vjb25kYXJ5IGNhY2hlIHN0b3JlLiBMZWFybiBtb3JlIGFib3V0IHRoZSBzZWNvbmRhcnkgY2FjaGUgc3RvcmUgaW4gdGhlXG4gICAqIFtjYWNoZWFibGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qYXJlZHdyYXkvY2FjaGVhYmxlL3RyZWUvbWFpbi9wYWNrYWdlcy9jYWNoZWFibGUjc3RvcmFnZS10aWVyaW5nLWFuZC1jYWNoaW5nKSBkb2N1bWVudGF0aW9uLlxuICAgKiBAcmV0dXJucyB7S2V5djxUPiB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCBzZWNvbmRhcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnNlY29uZGFyeTtcbiAgfVxuICAvKipcbiAgICogU2Vjb25kYXJ5IGNhY2hlIHN0b3JlLiBMZWFybiBtb3JlIGFib3V0IHRoZSBzZWNvbmRhcnkgY2FjaGUgc3RvcmUgaW4gdGhlXG4gICAqIFtjYWNoZWFibGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qYXJlZHdyYXkvY2FjaGVhYmxlL3RyZWUvbWFpbi9wYWNrYWdlcy9jYWNoZWFibGUjc3RvcmFnZS10aWVyaW5nLWFuZC1jYWNoaW5nKSBkb2N1bWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge0tleXYgfCB1bmRlZmluZWR9IHNlY29uZGFyeVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeShzZWNvbmRhcnkpIHtcbiAgICB0aGlzLl9jYWNoZS5zZWNvbmRhcnkgPSBzZWNvbmRhcnk7XG4gIH1cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIGtleXMgdG8gc3RvcmUgaW4gdGhlIGNhY2hlLiBpZiB0aGlzIGlzIHNldCB0byBhIHZhbHVlIGdyZWF0ZXIgdGhhbiAwLFxuICAgKiB0aGUgY2FjaGUgd2lsbCBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2Yga2V5cyBhbmQgd2lsbCBub3Qgc3RvcmUgbW9yZSB0aGFuIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGtleXMuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1heEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heEtleXM7XG4gIH1cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIGtleXMgdG8gc3RvcmUgaW4gdGhlIGNhY2hlLiBpZiB0aGlzIGlzIHNldCB0byBhIHZhbHVlIGdyZWF0ZXIgdGhhbiAwLFxuICAgKiB0aGUgY2FjaGUgd2lsbCBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2Yga2V5cyBhbmQgd2lsbCBub3Qgc3RvcmUgbW9yZSB0aGFuIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGtleXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhLZXlzXG4gICAqL1xuICBzZXQgbWF4S2V5cyhtYXhLZXlzKSB7XG4gICAgdGhpcy5fbWF4S2V5cyA9IG1heEtleXM7XG4gICAgaWYgKHRoaXMuX21heEtleXMgPiAwKSB7XG4gICAgICB0aGlzLl9jYWNoZS5zdGF0cy5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIGtleS92YWx1ZSBwYWlyIGluIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge1R9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdHRsXVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGFzeW5jIHNldChrZXksIHZhbHVlLCB0dGwpIHtcbiAgICBpZiAodGhpcy5fbWF4S2V5cyA+IDApIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoZS5zdGF0cy5jb3VudCA+PSB0aGlzLl9tYXhLZXlzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fY2FjaGUuc2V0KGtleS50b1N0cmluZygpLCB2YWx1ZSwgdHRsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0IG11bHRpcGxlIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgY2FjaGUuXG4gICAqIEBwYXJhbSB7UGFydGlhbE5vZGVDYWNoZUl0ZW1bXX0gbGlzdFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFzeW5jIG1zZXQobGlzdCkge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QpIHtcbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICBrZXk6IGl0ZW0ua2V5LnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlOiBpdGVtLnZhbHVlLFxuICAgICAgICB0dGw6IGl0ZW0udHRsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fY2FjaGUuc2V0TWFueShpdGVtcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHZhbHVlIGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0ga2V5XG4gICAqIEByZXR1cm5zIHthbnkgfCB1bmRlZmluZWR9XG4gICAqL1xuICBhc3luYyBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLmdldChrZXkudG9TdHJpbmcoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBtdWx0aXBsZSB2YWx1ZXMgZnJvbSB0aGUgY2FjaGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nIHwgbnVtYmVyPn0ga2V5c1xuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55IHwgdW5kZWZpbmVkPn1cbiAgICovXG4gIGFzeW5jIG1nZXQoa2V5cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHJlc3VsdFtrZXkudG9TdHJpbmcoKV0gPSBhd2FpdCB0aGlzLl9jYWNoZS5nZXQoa2V5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBrZXkgZnJvbSB0aGUgY2FjaGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBrZXlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBhc3luYyBkZWwoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLmRlbGV0ZShrZXkudG9TdHJpbmcoKSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBtdWx0aXBsZSBrZXlzIGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZyB8IG51bWJlcj59IGtleXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBhc3luYyBtZGVsKGtleXMpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUuZGVsZXRlTWFueShrZXlzLm1hcCgoa2V5KSA9PiBrZXkudG9TdHJpbmcoKSkpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciB0aGUgY2FjaGUuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYXN5bmMgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2V5IGV4aXN0cyBpbiB0aGUgY2FjaGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBrZXlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBhc3luYyBzZXRUdGwoa2V5LCB0dGwpIHtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5fY2FjaGUuZ2V0KGtleS50b1N0cmluZygpKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgYXdhaXQgdGhpcy5fY2FjaGUuc2V0KGtleS50b1N0cmluZygpLCBpdGVtLCB0dGwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXkgZXhpc3RzIGluIHRoZSBjYWNoZS4gSWYgaXQgZG9lcyBleGlzdCBpdCB3aWxsIGdldCB0aGUgdmFsdWUgYW5kIGRlbGV0ZSB0aGUgaXRlbSBmcm9tIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGtleVxuICAgKiBAcmV0dXJucyB7VCB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGFzeW5jIHRha2Uoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnRha2Uoa2V5LnRvU3RyaW5nKCkpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgYXdhaXQgdGhpcy5fY2FjaGUuZGlzY29ubmVjdCgpO1xuICB9XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBOb2RlQ2FjaGVFcnJvcnMgPSAvKiBAX19QVVJFX18gKi8gKChOb2RlQ2FjaGVFcnJvcnMyKSA9PiB7XG4gIE5vZGVDYWNoZUVycm9yczJbXCJFQ0FDSEVGVUxMXCJdID0gXCJDYWNoZSBtYXgga2V5cyBhbW91bnQgZXhjZWVkZWRcIjtcbiAgTm9kZUNhY2hlRXJyb3JzMltcIkVLRVlUWVBFXCJdID0gXCJUaGUga2V5IGFyZ3VtZW50IGhhcyB0byBiZSBvZiB0eXBlIGBzdHJpbmdgIG9yIGBudW1iZXJgLiBGb3VuZDogYF9fa2V5YFwiO1xuICBOb2RlQ2FjaGVFcnJvcnMyW1wiRUtFWVNUWVBFXCJdID0gXCJUaGUga2V5cyBhcmd1bWVudCBoYXMgdG8gYmUgYW4gYXJyYXkuXCI7XG4gIE5vZGVDYWNoZUVycm9yczJbXCJFVFRMVFlQRVwiXSA9IFwiVGhlIHR0bCBhcmd1bWVudCBoYXMgdG8gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgZm9yIHNob3J0aGFuZCB0dGwuXCI7XG4gIHJldHVybiBOb2RlQ2FjaGVFcnJvcnMyO1xufSkoTm9kZUNhY2hlRXJyb3JzIHx8IHt9KTtcbnZhciBOb2RlQ2FjaGUgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9ob29raWZpZWQyLkhvb2tpZmllZCB7XG4gIG9wdGlvbnMgPSB7XG4gICAgc3RkVFRMOiAwLFxuICAgIGNoZWNrcGVyaW9kOiA2MDAsXG4gICAgdXNlQ2xvbmVzOiB0cnVlLFxuICAgIGRlbGV0ZU9uRXhwaXJlOiB0cnVlLFxuICAgIG1heEtleXM6IC0xXG4gIH07XG4gIHN0b3JlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3N0YXRzID0gbmV3IGltcG9ydF9jYWNoZWFibGUyLkNhY2hlYWJsZVN0YXRzKHsgZW5hYmxlZDogdHJ1ZSB9KTtcbiAgX2NhY2hlYWJsZSA9IG5ldyBpbXBvcnRfY2FjaGVhYmxlMi5DYWNoZWFibGVNZW1vcnkoKTtcbiAgaW50ZXJ2YWxJZCA9IDA7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0SW50ZXJ2YWwoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIGtleSB2YWx1ZSBwYWlyLiBJdCBpcyBwb3NzaWJsZSB0byBkZWZpbmUgYSB0dGwgKGluIHNlY29uZHMpLiBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcy5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGtleSAtIGl0IHdpbGwgY29udmVydCB0aGUga2V5IHRvIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IFt0dGxdIC0gdGhpcyBpcyBpbiBzZWNvbmRzIGFuZCB1bmRlZmluZWQgd2lsbCB1c2UgdGhlIGRlZmF1bHQgdHRsXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUsIHR0bCA9IDApIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKFwiVGhlIGtleSBhcmd1bWVudCBoYXMgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYCBvciBgbnVtYmVyYC4gRm91bmQ6IGBfX2tleWBcIiAvKiBFS0VZVFlQRSAqLywga2V5KTtcbiAgICB9XG4gICAgaWYgKHR0bCAmJiB0eXBlb2YgdHRsICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiB0dGwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoXCJUaGUgdHRsIGFyZ3VtZW50IGhhcyB0byBiZSBhIG51bWJlciBvciBhIHN0cmluZyBmb3Igc2hvcnRoYW5kIHR0bC5cIiAvKiBFVFRMVFlQRSAqLywgdGhpcy5mb3JtYXRLZXkoa2V5KSk7XG4gICAgfVxuICAgIGNvbnN0IGtleVZhbHVlID0gdGhpcy5mb3JtYXRLZXkoa2V5KTtcbiAgICBsZXQgdHRsVmFsdWUgPSAwO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RkVFRMKSB7XG4gICAgICB0dGxWYWx1ZSA9IHRoaXMuZ2V0RXhwaXJhdGlvblRpbWVzdGFtcCh0aGlzLm9wdGlvbnMuc3RkVFRMKTtcbiAgICB9XG4gICAgaWYgKHR0bCkge1xuICAgICAgdHRsVmFsdWUgPSB0aGlzLmdldEV4cGlyYXRpb25UaW1lc3RhbXAodHRsKTtcbiAgICB9XG4gICAgbGV0IGV4cGlyYXRpb25UaW1lc3RhbXAgPSAwO1xuICAgIGlmICh0dGxWYWx1ZSAmJiB0dGxWYWx1ZSA+IDApIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lc3RhbXAgPSB0dGxWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5tYXhLZXlzKSB7XG4gICAgICBjb25zdCB7IG1heEtleXMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChtYXhLZXlzID4gLTEgJiYgdGhpcy5zdG9yZS5zaXplID49IG1heEtleXMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihcIkNhY2hlIG1heCBrZXlzIGFtb3VudCBleGNlZWRlZFwiIC8qIEVDQUNIRUZVTEwgKi8sIHRoaXMuZm9ybWF0S2V5KGtleSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0b3JlLnNldChrZXlWYWx1ZSwge1xuICAgICAga2V5OiBrZXlWYWx1ZSxcbiAgICAgIHZhbHVlLFxuICAgICAgdHRsOiBleHBpcmF0aW9uVGltZXN0YW1wXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwic2V0XCIsIGtleVZhbHVlLCB2YWx1ZSwgdHRsVmFsdWUpO1xuICAgIHRoaXMuX3N0YXRzLmluY3JlbWVudEtTaXplKGtleVZhbHVlKTtcbiAgICB0aGlzLl9zdGF0cy5pbmNyZW1lbnRWU2l6ZSh2YWx1ZSk7XG4gICAgdGhpcy5fc3RhdHMuc2V0Q291bnQodGhpcy5zdG9yZS5zaXplKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBtdWx0aXBsZSBrZXkgdmFsIHBhaXJzLiBJdCBpcyBwb3NzaWJsZSB0byBkZWZpbmUgYSB0dGwgKHNlY29uZHMpLiBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcy5cbiAgICogQHBhcmFtIHtQYXJ0aWFsTm9kZUNhY2hlSXRlbTxUPltdfSBkYXRhIGFuIGFycmF5IG9mIGtleSB2YWx1ZSBwYWlycyB3aXRoIG9wdGlvbmFsIHR0bFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIG1zZXQoZGF0YSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihcIlRoZSBrZXlzIGFyZ3VtZW50IGhhcyB0byBiZSBhbiBhcnJheS5cIiAvKiBFS0VZU1RZUEUgKi8pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YSkge1xuICAgICAgdGhpcy5zZXQoaXRlbS5rZXksIGl0ZW0udmFsdWUsIGl0ZW0udHRsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBzYXZlZCB2YWx1ZSBmcm9tIHRoZSBjYWNoZS4gUmV0dXJucyBhIHVuZGVmaW5lZCBpZiBub3QgZm91bmQgb3IgZXhwaXJlZC4gSWYgdGhlIHZhbHVlIHdhcyBmb3VuZCBpdCByZXR1cm5zIHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGtleSBpZiB0aGUga2V5IGlzIGEgbnVtYmVyIGl0IHdpbGwgY29udmVydCBpdCB0byBhIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7VH0gdGhlIHZhbHVlIG9yIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RvcmUuZ2V0KHRoaXMuZm9ybWF0S2V5KGtleSkpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChyZXN1bHQudHRsID4gMCkge1xuICAgICAgICBpZiAocmVzdWx0LnR0bCA8IERhdGUubm93KCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlbGV0ZU9uRXhwaXJlKSB7XG4gICAgICAgICAgICB0aGlzLmRlbChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zdGF0cy5pbmNyZW1lbnRNaXNzZXMoKTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJleHBpcmVkXCIsIHRoaXMuZm9ybWF0S2V5KGtleSksIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0cy5pbmNyZW1lbnRIaXRzKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlQ2xvbmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlYWJsZS5jbG9uZShyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cy5pbmNyZW1lbnRIaXRzKCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUNsb25lcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVhYmxlLmNsb25lKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0cy5pbmNyZW1lbnRNaXNzZXMoKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIG11bHRpcGxlIHNhdmVkIHZhbHVlcyBmcm9tIHRoZSBjYWNoZS4gUmV0dXJucyBhbiBlbXB0eSBvYmplY3Qge30gaWYgbm90IGZvdW5kIG9yIGV4cGlyZWQuXG4gICAqIElmIHRoZSB2YWx1ZSB3YXMgZm91bmQgaXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUga2V5IHZhbHVlIHBhaXIuXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nIHwgbnVtYmVyfSBrZXlzIGFuIGFycmF5IG9mIGtleXNcbiAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIFQgfCB1bmRlZmluZWQ+fSBhbiBvYmplY3Qgd2l0aCB0aGUga2V5IGFzIGEgcHJvcGVydHkgYW5kIHRoZSB2YWx1ZSBhcyB0aGUgdmFsdWVcbiAgICovXG4gIG1nZXQoa2V5cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXN1bHRbdGhpcy5mb3JtYXRLZXkoa2V5KV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjYWNoZWQgdmFsdWUgYW5kIHJlbW92ZSB0aGUga2V5IGZyb20gdGhlIGNhY2hlLiBFcXVpdmFsZW50IHRvIGNhbGxpbmcgZ2V0KGtleSkgKyBkZWwoa2V5KS5cbiAgICogVXNlZnVsIGZvciBpbXBsZW1lbnRpbmcgc2luZ2xlIHVzZSBtZWNoYW5pc20gc3VjaCBhcyBPVFAsIHdoZXJlIG9uY2UgYSB2YWx1ZSBpcyByZWFkIGl0IHdpbGwgYmVjb21lIG9ic29sZXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0ga2V5XG4gICAqIEByZXR1cm5zIHtUIHwgdW5kZWZpbmVkfSB0aGUgdmFsdWUgb3IgdW5kZWZpbmVkXG4gICAqL1xuICB0YWtlKGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0KGtleSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhpcy5kZWwoa2V5KTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlQ2xvbmVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWFibGUuY2xvbmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGtleS4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlbGV0ZWQgZW50cmllcy4gQSBkZWxldGUgd2lsbCBuZXZlciBmYWlsLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IEFycmF5PHN0cmluZyB8IG51bWJlcj59IGtleSBpZiB0aGUga2V5IGlzIGEgbnVtYmVyIGl0IHdpbGwgY29udmVydCBpdCB0byBhIHN0cmluZy4gaWYgYW4gYXJyYXkgaXMgcGFzc2VkIGl0IHdpbGwgZGVsZXRlIGFsbCBrZXlzIGluIHRoZSBhcnJheS5cbiAgICogQHJldHVybnMge251bWJlcn0gaWYgaXQgd2FzIHN1Y2Nlc3NmdWwgaXQgd2lsbCByZXR1cm4gdGhlIGNvdW50IHRoYXQgd2FzIGRlbGV0ZWRcbiAgICovXG4gIGRlbChrZXkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGVsKGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RvcmUuZ2V0KHRoaXMuZm9ybWF0S2V5KGtleSkpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGNvbnN0IGtleVZhbHVlID0gdGhpcy5mb3JtYXRLZXkoa2V5KTtcbiAgICAgIHRoaXMuc3RvcmUuZGVsZXRlKGtleVZhbHVlKTtcbiAgICAgIHRoaXMuZW1pdChcImRlbFwiLCBrZXlWYWx1ZSwgcmVzdWx0LnZhbHVlKTtcbiAgICAgIHRoaXMuX3N0YXRzLmRlY3JlYXNlS1NpemUoa2V5VmFsdWUpO1xuICAgICAgdGhpcy5fc3RhdHMuZGVjcmVhc2VWU2l6ZShyZXN1bHQudmFsdWUpO1xuICAgICAgdGhpcy5fc3RhdHMuc2V0Q291bnQodGhpcy5zdG9yZS5zaXplKTtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGFsbCBrZXlzIGluIEFycmF5IHRoYXQgZXhpc3QuIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWxldGVkIGVudHJpZXMuXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nIHwgbnVtYmVyPn0ga2V5cyBhbiBhcnJheSBvZiBrZXlzXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb3VudCBvZiBkZWxldGVkIGtleXNcbiAgICovXG4gIG1kZWwoa2V5cykge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLmRlbChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBSZWRlZmluZSB0aGUgdHRsIG9mIGEga2V5LiBSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBoYXMgYmVlbiBmb3VuZCBhbmQgY2hhbmdlZC5cbiAgICogT3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuIElmIHRoZSB0dGwtYXJndW1lbnQgaXNuJ3QgcGFzc2VkIHRoZSBkZWZhdWx0LVRUTCB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBrZXkgaWYgdGhlIGtleSBpcyBhIG51bWJlciBpdCB3aWxsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmdcbiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IFt0dGxdIHRoZSB0dGwgaW4gc2Vjb25kcyBpZiBudW1iZXIsIG9yIGEgc2hvcnRoYW5kIHN0cmluZyBsaWtlICcxaCcgZm9yIDEgaG91clxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUga2V5IGhhcyBiZWVuIGZvdW5kIGFuZCBjaGFuZ2VkLiBPdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICovXG4gIHR0bChrZXksIHR0bCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RvcmUuZ2V0KHRoaXMuZm9ybWF0S2V5KGtleSkpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGNvbnN0IHR0bFZhbHVlID0gdHRsID8/IHRoaXMub3B0aW9ucy5zdGRUVEw7XG4gICAgICByZXN1bHQudHRsID0gdGhpcy5nZXRFeHBpcmF0aW9uVGltZXN0YW1wKHR0bFZhbHVlKTtcbiAgICAgIHRoaXMuc3RvcmUuc2V0KHRoaXMuZm9ybWF0S2V5KGtleSksIHJlc3VsdCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBSZWNlaXZlIHRoZSB0dGwgb2YgYSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBrZXkgaWYgdGhlIGtleSBpcyBhIG51bWJlciBpdCB3aWxsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmdcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gMCBpZiB0aGlzIGtleSBoYXMgbm8gdHRsLCB1bmRlZmluZWQgaWYgdGhpcyBrZXkgaXMgbm90IGluIHRoZSBjYWNoZSxcbiAgICogYSB0aW1lc3RhbXAgaW4gbXMgcmVwcmVzZW50aW5nIHRoZSB0aW1lIGF0IHdoaWNoIHRoaXMga2V5IHdpbGwgZXhwaXJlXG4gICAqL1xuICBnZXRUdGwoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zdG9yZS5nZXQodGhpcy5mb3JtYXRLZXkoa2V5KSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdC50dGwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0LnR0bDtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZXhpc3Rpbmcga2V5cy4gWyBcImFsbFwiLCBcIm15XCIsIFwia2V5c1wiLCBcImZvb1wiLCBcImJhclwiIF1cbiAgICogQHJldHVybnMge3N0cmluZ1tdfSBhbiBhcnJheSBvZiBhbGwga2V5c1xuICAgKi9cbiAga2V5cygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLnN0b3JlLmtleXMoKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGtleSBpcyBjYWNoZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBrZXkgaWYgdGhlIGtleSBpcyBhIG51bWJlciBpdCB3aWxsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGtleSBpcyBjYWNoZWRcbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5oYXModGhpcy5mb3JtYXRLZXkoa2V5KSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YXRzIG9mIHRoZSBjYWNoZVxuICAgKiBAcmV0dXJucyB7Tm9kZUNhY2hlU3RhdHN9IHRoZSBzdGF0cyBvZiB0aGUgY2FjaGVcbiAgICovXG4gIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAga2V5czogdGhpcy5fc3RhdHMuY291bnQsXG4gICAgICBoaXRzOiB0aGlzLl9zdGF0cy5oaXRzLFxuICAgICAgbWlzc2VzOiB0aGlzLl9zdGF0cy5taXNzZXMsXG4gICAgICBrc2l6ZTogdGhpcy5fc3RhdHMua3NpemUsXG4gICAgICB2c2l6ZTogdGhpcy5fc3RhdHMudnNpemVcbiAgICB9O1xuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICAvKipcbiAgICogRmx1c2ggdGhlIHdob2xlIGRhdGEuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZmx1c2hBbGwoKSB7XG4gICAgdGhpcy5zdG9yZS5jbGVhcigpO1xuICAgIHRoaXMuZmx1c2hTdGF0cygpO1xuICAgIHRoaXMuZW1pdChcImZsdXNoXCIpO1xuICB9XG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgc3RhdHMuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZmx1c2hTdGF0cygpIHtcbiAgICB0aGlzLl9zdGF0cyA9IG5ldyBpbXBvcnRfY2FjaGVhYmxlMi5DYWNoZWFibGVTdGF0cyh7IGVuYWJsZWQ6IHRydWUgfSk7XG4gICAgdGhpcy5lbWl0KFwiZmx1c2hfc3RhdHNcIik7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBjYWNoZS4gVGhpcyB3aWxsIGNsZWFyIHRoZSBpbnRlcnZhbCB0aW1lb3V0IHdoaWNoIGlzIHNldCBvbiBjaGVjayBwZXJpb2Qgb3B0aW9uLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuc3RvcEludGVydmFsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZXJ2YWwgaWRcbiAgICogQHJldHVybnMge251bWJlciB8IE5vZGVKUy5UaW1lb3V0fSB0aGUgaW50ZXJ2YWwgaWRcbiAgICovXG4gIGdldEludGVydmFsSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWxJZDtcbiAgfVxuICBmb3JtYXRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS50b1N0cmluZygpO1xuICB9XG4gIGdldEV4cGlyYXRpb25UaW1lc3RhbXAodHRsSW5TZWNvbmRzKSB7XG4gICAgaWYgKHR5cGVvZiB0dGxJblNlY29uZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X2NhY2hlYWJsZTIuc2hvcnRoYW5kVG9UaW1lKSh0dGxJblNlY29uZHMpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0dGxJbk1pbGxpc2Vjb25kcyA9IHR0bEluU2Vjb25kcyAqIDFlMztcbiAgICBjb25zdCBleHBpcmF0aW9uVGltZXN0YW1wID0gY3VycmVudFRpbWVzdGFtcCArIHR0bEluTWlsbGlzZWNvbmRzO1xuICAgIHJldHVybiBleHBpcmF0aW9uVGltZXN0YW1wO1xuICB9XG4gIHN0YXJ0SW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jaGVja3BlcmlvZCAmJiB0aGlzLm9wdGlvbnMuY2hlY2twZXJpb2QgPiAwKSB7XG4gICAgICBjb25zdCBjaGVja1BlcmlvZGluU2Vjb25kcyA9IHRoaXMub3B0aW9ucy5jaGVja3BlcmlvZCAqIDFlMztcbiAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgdGhpcy5jaGVja0RhdGEoKTtcbiAgICAgIH0sIGNoZWNrUGVyaW9kaW5TZWNvbmRzKS51bnJlZigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmludGVydmFsSWQgPSAwO1xuICB9XG4gIGNoZWNrRGF0YSgpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnN0b3JlLmVudHJpZXMoKSkge1xuICAgICAgaWYgKHZhbHVlLnR0bCA+IDAgJiYgdmFsdWUudHRsIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlbGV0ZU9uRXhwaXJlKSB7XG4gICAgICAgICAgdGhpcy5kZWwoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJleHBpcmVkXCIsIHRoaXMuZm9ybWF0S2V5KGtleSksIHZhbHVlLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcEludGVydmFsKCkge1xuICAgIGlmICh0aGlzLmludGVydmFsSWQgIT09IDApIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IDA7XG4gICAgfVxuICB9XG4gIGNyZWF0ZUVycm9yKGVycm9yQ29kZSwga2V5KSB7XG4gICAgbGV0IGVycm9yID0gZXJyb3JDb2RlO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGVycm9yID0gZXJyb3IucmVwbGFjZShcIl9fa2V5XCIsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3IpO1xuICB9XG59O1xudmFyIGluZGV4X2RlZmF1bHQgPSBOb2RlQ2FjaGU7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgTm9kZUNhY2hlLFxuICBOb2RlQ2FjaGVFcnJvcnMsXG4gIE5vZGVDYWNoZVN0b3JlXG59KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@cacheable/node-cache/dist/index.cjs\n");

/***/ })

};
;